CCS PCH C Compiler, Version 3.214, 26547               07-Oct-15 16:51

               Filename: H:\Electrical Engineering Technology\Classes\Programming\Microcontrollers\Microcontrollers-master\Microcontrollers-master\Code-Design\Code\Challenges\Challenge_1.LST

               ROM used: 4056 bytes (12%)
                         Largest free fragment is 28708
               RAM used: 91 (6%) at main() level
                         141 (9%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  GOTO   0D6A
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVF   FE9,W
0010:  MOVWF  07
0012:  MOVF   FEA,W
0014:  MOVWF  08
0016:  MOVF   FE1,W
0018:  MOVWF  09
001A:  MOVF   FE2,W
001C:  MOVWF  0A
001E:  MOVF   FD9,W
0020:  MOVWF  0B
0022:  MOVF   FDA,W
0024:  MOVWF  0C
0026:  MOVF   FF3,W
0028:  MOVWF  14
002A:  MOVF   FF4,W
002C:  MOVWF  15
002E:  MOVF   FE0,W
0030:  MOVWF  0D
0032:  MOVLB  0
0034:  MOVF   00,W
0036:  MOVWF  0F
0038:  MOVF   01,W
003A:  MOVWF  10
003C:  MOVF   02,W
003E:  MOVWF  11
0040:  MOVF   03,W
0042:  MOVWF  12
0044:  MOVF   04,W
0046:  MOVWF  13
0048:  BTFSS  F9D.6
004A:  GOTO   0054
004E:  BTFSC  F9E.6
0050:  GOTO   0484
0054:  MOVF   0F,W
0056:  MOVWF  00
0058:  MOVF   10,W
005A:  MOVWF  01
005C:  MOVF   11,W
005E:  MOVWF  02
0060:  MOVF   12,W
0062:  MOVWF  03
0064:  MOVF   13,W
0066:  MOVWF  04
0068:  MOVF   0D,W
006A:  MOVWF  FE0
006C:  BSF    0D.7
006E:  MOVF   07,W
0070:  MOVWF  FE9
0072:  MOVF   08,W
0074:  MOVWF  FEA
0076:  MOVF   09,W
0078:  MOVWF  FE1
007A:  MOVF   0A,W
007C:  MOVWF  FE2
007E:  MOVF   0B,W
0080:  MOVWF  FD9
0082:  MOVF   0C,W
0084:  MOVWF  FDA
0086:  MOVF   14,W
0088:  MOVWF  FF3
008A:  MOVF   15,W
008C:  MOVWF  FF4
008E:  MOVF   05,W
0090:  MOVFF  06,FD8
0094:  RETFIE 0
....................  /* Initial lcd test  
....................    2015-.09.24  
....................    ../../designs/LCDpanel_1.design  
.................... */  
....................   
.................... #include "../Library/Library_18f4520.h" 
....................  /*  
....................  * Library_18f4520.h  
....................  *  
....................  *  
....................  */  
....................   
.................... // Included for compiler  
.................... // #include <18f452.h> // Different compiler  
.................... #include <18f4520.h> // Class compiler 
....................  //////// Standard Header file for the PIC18F4520 device ////////////////  
.................... #device PIC18F4520  
.................... #list  
....................  
....................   
.................... // Set lock bits and fuses  
.................... #include "../library/FusesLockBits.h" 
....................    
.................... #use delay (clock = 200000000)  
*
051C:  CLRF   FEA
051E:  MOVLW  6C
0520:  MOVWF  FE9
0522:  MOVF   FEF,W
0524:  BZ    0540
0526:  MOVLW  40
0528:  MOVWF  01
052A:  CLRF   00
052C:  DECFSZ 00,F
052E:  BRA    052C
0530:  DECFSZ 01,F
0532:  BRA    052A
0534:  MOVLW  D9
0536:  MOVWF  00
0538:  DECFSZ 00,F
053A:  BRA    0538
053C:  DECFSZ FEF,F
053E:  BRA    0526
0540:  RETLW  00
.................... #fuses HS, NOWDT, NOLvP  
....................  
....................   
.................... // All register addresses are defined as: #define REGISTER_<name-of-register> <hex-of-address>  
.................... #include "../library/Register_Addresses_Definitions.h" 
....................  /*   
....................  * Register_Addresses_Definitions.h  
....................  *   
....................  * Register addresses  
....................  * 	The addresses are all defined as:  
....................  * 		#define REGISTER_<name-of-register> <hex-of-address>  
....................  *   
....................  * Notes:  
....................  * 	1: This is not a physical register.  
....................  * 	2: Unimplemented registers are read as ‘0’.  
....................  * 	3: This register is not available on 28-pin devices.  
....................  *   
....................  */  
....................   
.................... #define REGISTER_TOSU 0xFFF               // Comments needed  
.................... #define REGISTER_TOSH 0xFFE               // Comments needed  
.................... #define REGISTER_TOSL 0xFFD               // Comments needed  
....................                                                
.................... #define REGISTER_STKPTR 0xFFC             // Comments needed  
....................                                                
.................... #define REGISTER_PCLATU 0xFFB             // Comments needed  
.................... #define REGISTER_PCLATH 0xFFA             // Comments needed  
.................... #define REGISTER_PCL 0xFF9                // Comments needed  
....................                                               
.................... #define REGISTER_TBLPTRU 0xFF8            // Comments needed  
.................... #define REGISTER_TBLPTRH 0xFF7            // Comments needed  
.................... #define REGISTER_TBLPTRL 0xFF6            // Comments needed  
.................... #define REGISTER_TABLAT 0xFF5             // Comments needed  
....................                                                
.................... #define REGISTER_PRODH 0xFF4              // Comments needed  
.................... #define REGISTER_PRODL 0xFF3              // Comments needed  
....................                                                
.................... #define REGISTER_INTCON 0xFF2             // Comments needed  
.................... #define REGISTER_INTCON2 0xFF1            // Comments needed  
.................... #define REGISTER_INTCON3 0xFF0            // Comments needed  
.................... #define REGISTER_INDF0 0xFEF              // 1: This is not a physical register.  
....................   
.................... #define REGISTER_POSTINC0 0xFEE           // 1: This is not a physical register.  
.................... #define REGISTER_POSTDEC0 0xFED           // 1: This is not a physical register.  
.................... #define REGISTER_PREINC0 0xFEC            // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PLUSW0 0xFEB             // 1: This is not a physical register.  
....................   
.................... #define REGISTER_FSR0H 0xFEA              // Comments needed  
.................... #define REGISTER_FSR0L 0xFE9              // Comments needed  
....................   
.................... #define REGISTER_WREG 0xFE8               // Comments needed  
....................   
.................... #define REGISTER_INDF1 0xFE7              // 1: This is not a physical register.  
....................   
.................... #define REGISTER_POSTINC1 0xFE6           // 1: This is not a physical register.  
.................... #define REGISTER_POSTDEC1 0xFE5           // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PREINC1 0xFE4            // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PLUSW1 0xFE3             // 1: This is not a physical register.  
....................   
.................... #define REGISTER_FSR1H 0xFE2              // Comments needed  
.................... #define REGISTER_FSR1L 0xFE1              // Comments needed  
....................   
.................... #define REGISTER_BSR 0xFE0                // Comments needed  
....................   
.................... #define REGISTER_INDF2 0xFDF              // 1: This is not a physical register.  
....................   
.................... #define REGISTER_POSTINC2 0xFDE           // 1: This is not a physical register.  
.................... #define REGISTER_POSTDEC2 0xFDD           // 1: This is not a physical register.  
.................... #define REGISTER_PREINC2 0xFDC            // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PLUSW2 0xFDB             // 1: This is not a physical register.  
....................   
.................... #define REGISTER_FSR2H 0xFDA              // Comments needed  
.................... #define REGISTER_FSR2L 0xFD9              // Comments needed  
....................   
.................... #define REGISTER_STATUS 0xFD8             // Comments needed  
....................   
.................... #define REGISTER_TMR0H 0xFD7              // Comments needed  
.................... #define REGISTER_TMR0L 0xFD6              // Comments needed  
.................... #define REGISTER_T0CON 0xFD5              // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_0 0xFD4    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_OSCCON 0xFD3             // Comments needed  
....................   
.................... #define REGISTER_HLVDCON 0xFD2            // Comments needed  
....................   
.................... #define REGISTER_WDTCON 0xFD1             // Comments needed  
....................   
.................... #define REGISTER_RCON 0xFD0               // Comments needed  
....................   
.................... #define REGISTER_TMR1H 0xFCF              // Comments needed  
.................... #define REGISTER_TMR1L 0xFCE              // Comments needed  
.................... #define REGISTER_T1CON 0xFCD              // Comments needed  
.................... #define REGISTER_TMR2 0xFCC               // Comments needed  
....................   
.................... #define REGISTER_PR2 0xFCB                // Comments needed  
....................   
.................... #define REGISTER_T2CON 0xFCA              // Comments needed  
....................   
.................... #define REGISTER_SSPBUF 0xFC9             // Comments needed  
.................... #define REGISTER_SSPADD 0xFC8             // Comments needed  
.................... #define REGISTER_SSPSTAT 0xFC7            // Comments needed  
.................... #define REGISTER_SSPCON1 0xFC6            // Comments needed  
.................... #define REGISTER_SSPCON2 0xFC5            // Comments needed  
....................   
.................... #define REGISTER_ADRESH 0xFC4             // Comments needed  
.................... #define REGISTER_ADRESL 0xFC3             // Comments needed  
.................... #define REGISTER_ADCON0 0xFC2             // Comments needed  
.................... #define REGISTER_ADCON1 0xFC1             // Comments needed  
.................... #define REGISTER_ADCON2 0xFC0             // Comments needed  
....................   
.................... #define REGISTER_CCPR1H 0xFBF             // Comments needed  
.................... #define REGISTER_CCPR1L 0xFBE             // Comments needed  
.................... #define REGISTER_CCP1CON 0xFBD            // Comments needed  
.................... #define REGISTER_CCPR2H 0xFBC             // Comments needed  
.................... #define REGISTER_CCPR2L 0xFBB             // Comments needed  
.................... #define REGISTER_CCP2CON 0xFBA            // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_1 0xFB9    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_BAUDCON 0xFB8            // Comments needed  
....................   
.................... #define REGISTER_PWM1CON 0xFB7            // 3: This register is not available on 28-pin devices.  
....................   
.................... #define REGISTER_ECCP1AS 0xFB6            // 3: This register is not available on 28-pin devices.  
....................   
.................... #define REGISTER_CVRCON 0xFB5             // Comments needed  
.................... #define REGISTER_CMCON 0xFB4              // Comments needed  
.................... #define REGISTER_TMR3H 0xFB3              // Comments needed  
.................... #define REGISTER_TMR3L 0xFB2              // Comments needed  
.................... #define REGISTER_T3CON 0xFB1              // Comments needed  
....................   
.................... #define REGISTER_SPBRGH 0xFB0             // Comments needed  
.................... #define REGISTER_SPBRG 0xFAF              // Comments needed  
.................... #define REGISTER_RCREG 0xFAE              // Comments needed  
....................   
.................... #define REGISTER_TXREG 0xFAD              // Comments needed  
.................... #define REGISTER_TXSTA 0xFAC              // Comments needed  
.................... #define REGISTER_RCSTA 0xFAB              // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_2 0xFAA    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_EEADR 0xFA9              // Comments needed  
.................... #define REGISTER_EEDATA 0xFA8             // Comments needed  
.................... #define REGISTER_EECON2 0xFA7             // 1: This is not a physical register.  
.................... #define REGISTER_EECON1 0xFA6             // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_3 0xFA5    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_4 0xFA4    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_5 0xFA3    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_IPR2 0xFA2               // Comments needed  
.................... #define REGISTER_PIR2 0xFA1               // Comments needed  
.................... #define REGISTER_PIE2 0xFA0               // Comments needed  
.................... #define REGISTER_IPR1 0xF9F               // Comments needed  
.................... #define REGISTER_PIR1 0xF9E               // Comments needed  
.................... #define REGISTER_PIE1 0xF9D               // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_6 0xF9C    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_OSCTUNE 0xF9B            // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_7 0xF9A    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_8 0xF99    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_9 0xF98    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_10 0xF97   // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_TRISE 0xF96              // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_TRISD 0xF95              // Comments needed  
.................... #define REGISTER_TRISC 0xF94              // Comments needed  
.................... #define REGISTER_TRISB 0xF93              // Comments needed  
.................... #define REGISTER_TRISA 0xF92              // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_11 0xF91   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_12 0xF90   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_13 0xF8F   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_14 0xF8E   // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_LATE 0xF8D               // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_LATD 0xF8C               // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_LATC 0xF8B               // Comments needed  
.................... #define REGISTER_LATB 0xF8A               // Comments needed  
.................... #define REGISTER_LATA 0xF89               // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_15 0xF88   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_16 0xF87   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_17 0xF86   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_18 0xF85   // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_PORTE 0xF84              // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_PORTD 0xF83              // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_PORTC 0xF82              // Comments needed  
.................... #define REGISTER_PORTB 0xF81              // Comments needed  
.................... #define REGISTER_PORTA 0xF80              // Comments needed  
....................  
....................   
.................... // Pointers to TRIS PORT and LAT registers  
.................... #include "../library/TRIS_PORT_LAT.h" 
....................  /*   
....................  * TRIS_PORT_LAT.h  
....................  *   
....................  * GPIO  
....................  *   
....................  */  
....................   
.................... int *TRISA = REGISTER_TRISA;  
.................... int *TRISB = REGISTER_TRISB;  
.................... int *TRISC = REGISTER_TRISC;  
.................... int *TRISD = REGISTER_TRISD;  
.................... int *TRISE = REGISTER_TRISE;  
....................   
.................... int *PORTA = REGISTER_PORTA;  
.................... int *PORTB = REGISTER_PORTB;  
.................... int *PORTC = REGISTER_PORTC;  
.................... int *PORTD = REGISTER_PORTD;  
.................... int *PORTE = REGISTER_PORTE;  
....................   
.................... int *LATA = REGISTER_LATA;  
.................... int *LATB = REGISTER_LATB;  
.................... int *LATC = REGISTER_LATC;  
.................... int *LATD = REGISTER_LATD;  
.................... int *LATE = REGISTER_LATE; 
....................   
.................... // Structures for analog to digital circuits and defins for Q and L  
.................... #include "../library/Analog_To_Digital.h" 
....................  /*  
....................  * Analog_To_Digital.h  
....................  *   
....................  * Analog to digital circuit connections  
....................  *   
....................  */  
....................   
.................... #define L *ADRESH  
.................... #define Q *ADRESL  
....................   
.................... int16 *ADRESH = REGISTER_ADRESH;  
.................... int16 *ADRESL = REGISTER_ADRESL;  
....................   
.................... struct ADCON_0{  
....................    int ADON:1;  
....................    int GODONE:1;  
....................    int CHSx:4;  
....................    int unused:2;  
.................... };  
.................... struct ADCON_0 *ADCON0 = REGISTER_ADCON0;  
....................   
.................... struct ADCON_1{  
....................    int PCFGx:4;  
....................    int VCFG0:1;  
....................    int VCFG1:1;  
....................    int unused:2;  
.................... };  
.................... struct ADCON_1 *ADCON1 = REGISTER_ADCON1;  
....................   
.................... struct ADCON_2{  
....................    int ADCSx:3;  
....................    int ACQTx:3;  
....................    int unused:1;  
....................    int ADFM:1;  
.................... };  
.................... struct ADCON_2 *ADCON2 = REGISTER_ADCON2;  
....................  
....................   
.................... // Structures for interrupt curcuits  
.................... #include "../library/Interrupts.h" 
....................  /*   
....................  * Interrupts.h  
....................  *   
....................  * External interrupt control  
....................  *   
....................  */  
....................   
.................... struct INTCON_{  
.................... 	int RBIF:1;  
.................... 	int INT0IF:1;  
.................... 	int TMR0IF:1;  
.................... 	int RBIE:1;  
.................... 	int INT0IE:1;  
.................... 	int TMR0IE:1;  
.................... 	int PEIE:1;  
.................... 	int GIE:1;  
.................... 	};  
.................... struct INTCON_ *INTCON = REGISTER_INTCON;  
....................   
.................... struct INTCON_2{  
.................... 	int RBIP:1;  
.................... 	int UNIMPLEMENTED_0:1;  
.................... 	int TMROIP:1;  
.................... 	int UNIMPLEMENTED_1:1;  
.................... 	int INTEDG2:1;  
.................... 	int INTEDG1:1;  
.................... 	int INTEDG0:1;  
.................... 	int RBPU:1;  
.................... 	};  
.................... struct INTCON_2 *INTCON2 = REGISTER_INTCON2;  
....................   
.................... struct INTCON_3{  
.................... 	int INT1F:1;  
.................... 	int INT2F:1;  
.................... 	int UNIMPLEMENTED_0:1;  
.................... 	int INT1E:1;  
.................... 	int INT2E:1;  
.................... 	int UNIMPLEMENTED_1:1;  
.................... 	int INT1P:1;  
.................... 	int INT2P:1;  
.................... 	};  
.................... struct INTCON_3 *INTCON3 = REGISTER_INTCON3;  
....................   
.................... /*  
....................  *   
....................  * Peripheral Interrupts Control Registers  
....................  *   
....................  */  
....................   
.................... struct PIE_1{  
.................... 	int TMR1IE:1;  
.................... 	int TMR2IE:1;  
.................... 	int CCP1IE:1;  
.................... 	int SSPIE:1;  
.................... 	int TXIE:1;  
.................... 	int RCIE:1;  
.................... 	int ADIE:1;  
.................... 	int PSPIE:1;  
.................... 	};  
.................... struct PIE_1 *PIE1 = REGISTER_PIE1;  
....................  
....................   
.................... // Custom libraries for keypad and LCD connections  
.................... #include "../library/Keypad_Connection.h" 
....................  /*  
....................  * Keypad_Connection.h  
....................  *  
....................  * Keypad Connection to PORTB  
....................  *  
....................  */  
....................   
.................... // Coloum references  
.................... #define C0 0x3  
.................... #define C1 0x5  
.................... #define C2 0x6  
....................   
.................... // Row references  
.................... #define R0 0xE  
.................... #define R1 0xD  
.................... #define R2 0xB  
.................... #define R3 0x7  
....................   
.................... // Default press  
.................... #define defaultPress ' '  
....................   
.................... struct KeypadConnection{  
....................    int COL:3;  
....................    int unused:1;  
....................    int ROW:4;  
.................... };  
.................... struct KeypadConnection *KEYPAD = REGISTER_PORTB; // PORTB  
....................   
.................... // Declarations  
.................... char keyPress(void);  
....................   
.................... // Definitions  
.................... char keyPress(void){  
....................    char press = defaultPress;  
*
0614:  MOVLW  20
0616:  MOVWF  59
....................   
....................    KEYPAD->COL=C0;  
0618:  MOVFF  48,FE9
061C:  MOVFF  49,FEA
0620:  MOVLW  F8
0622:  ANDWF  FEF,W
0624:  IORLW  03
0626:  MOVWF  FEF
....................    switch(KEYPAD->ROW){  
0628:  MOVFF  48,FE9
062C:  MOVFF  49,FEA
0630:  MOVFF  FEF,00
0634:  SWAPF  00,W
0636:  ANDLW  0F
0638:  XORLW  0E
063A:  BZ    064A
063C:  XORLW  03
063E:  BZ    0650
0640:  XORLW  06
0642:  BZ    0656
0644:  XORLW  0C
0646:  BZ    065C
0648:  BRA    0662
....................       case R0:  
....................          press = '1';  
064A:  MOVLW  31
064C:  MOVWF  59
....................          break;  
064E:  BRA    0662
....................       case R1:  
....................          press = '4';  
0650:  MOVLW  34
0652:  MOVWF  59
....................          break;  
0654:  BRA    0662
....................       case R2:  
....................          press = '7';  
0656:  MOVLW  37
0658:  MOVWF  59
....................          break;  
065A:  BRA    0662
....................       case R3:  
....................          press = '*';  
065C:  MOVLW  2A
065E:  MOVWF  59
....................          break;  
0660:  BRA    0662
....................       default:  
....................    }  
....................   
....................    KEYPAD->COL=C1;  
0662:  MOVFF  48,FE9
0666:  MOVFF  49,FEA
066A:  MOVLW  F8
066C:  ANDWF  FEF,W
066E:  IORLW  05
0670:  MOVWF  FEF
....................    switch(KEYPAD->ROW){  
0672:  MOVFF  48,FE9
0676:  MOVFF  49,FEA
067A:  MOVFF  FEF,00
067E:  SWAPF  00,W
0680:  ANDLW  0F
0682:  XORLW  0E
0684:  BZ    0694
0686:  XORLW  03
0688:  BZ    069A
068A:  XORLW  06
068C:  BZ    06A0
068E:  XORLW  0C
0690:  BZ    06A6
0692:  BRA    06AC
....................       case R0:  
....................          press = '2';  
0694:  MOVLW  32
0696:  MOVWF  59
....................          break;  
0698:  BRA    06AC
....................       case R1:  
....................          press = '5';  
069A:  MOVLW  35
069C:  MOVWF  59
....................          break;  
069E:  BRA    06AC
....................       case R2:  
....................          press = '8';  
06A0:  MOVLW  38
06A2:  MOVWF  59
....................          break;  
06A4:  BRA    06AC
....................       case R3:  
....................          press = '0';  
06A6:  MOVLW  30
06A8:  MOVWF  59
....................          break;  
06AA:  BRA    06AC
....................       default:  
....................    }  
....................   
....................    KEYPAD->COL=C2;  
06AC:  MOVFF  48,FE9
06B0:  MOVFF  49,FEA
06B4:  MOVLW  F8
06B6:  ANDWF  FEF,W
06B8:  IORLW  06
06BA:  MOVWF  FEF
....................    switch(KEYPAD->ROW){  
06BC:  MOVFF  48,FE9
06C0:  MOVFF  49,FEA
06C4:  MOVFF  FEF,00
06C8:  SWAPF  00,W
06CA:  ANDLW  0F
06CC:  XORLW  0E
06CE:  BZ    06DE
06D0:  XORLW  03
06D2:  BZ    06E4
06D4:  XORLW  06
06D6:  BZ    06EA
06D8:  XORLW  0C
06DA:  BZ    06F0
06DC:  BRA    06F6
....................       case R0:  
....................          press = '3';  
06DE:  MOVLW  33
06E0:  MOVWF  59
....................          break;  
06E2:  BRA    06F6
....................       case R1:  
....................          press = '6';  
06E4:  MOVLW  36
06E6:  MOVWF  59
....................          break;  
06E8:  BRA    06F6
....................       case R2:  
....................          press = '9';  
06EA:  MOVLW  39
06EC:  MOVWF  59
....................          break;  
06EE:  BRA    06F6
....................       case R3:  
....................          press = '#';  
06F0:  MOVLW  23
06F2:  MOVWF  59
....................          break;  
06F4:  BRA    06F6
....................       default:  
....................    }  
....................   
....................    return(press);  
06F6:  MOVFF  59,01
.................... }  
06FA:  GOTO   0F1E (RETURN)
....................  
.................... #include "../library/Modified_LCD.h" 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////                             Modified LCD.C                        ////  
.................... ////                 Driver for common LCD modules                     ////  
.................... ////                                                                   ////  
.................... ////  lcd_init()   Must be called before any other function.           ////  
.................... ////         ***This function was modified to fit the Samsumgs6A0069   ////  
.................... ////                                                                   ////  
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     ////  
.................... ////                     The following have special meaning:           ////  
.................... ////                      \f  Clear display                            ////  
.................... ////                      \n  Go to start of second line               ////  
.................... ////                      \b  Move back one position                   ////  
.................... ////                                                                   ////  
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    ////  
.................... ////                                                                   ////  
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         ////  
.................... ////                                                                   ////  
.................... ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... // As defined in the following structure the pin connection is as follows:  
.................... //     D0  enable  
.................... //     D1  rs  
.................... //     D2  rw  
.................... //     D4  D4  
.................... //     D5  D5  
.................... //     D6  D6  
.................... //     D7  D7  
.................... //  
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used.  
....................   
.................... // Un-comment the following define to use port B  
.................... #define use_portb_lcd FALSE  
....................   
.................... // Function declerations  
.................... char lcd_getc( BYTE x, BYTE y);  
.................... void lcd_putc( char c);  
.................... void lcd_gotoxy( BYTE x, BYTE y);  
.................... void lcd_init();  
.................... void lcd_send_byte( BYTE address, BYTE n );  
.................... void lcd_send_nibble( BYTE n );  
.................... BYTE lcd_read_byte();  
....................   
....................   
....................   
.................... struct lcd_pin_map {                 // This structure is overlayed  
....................            BOOLEAN enable;           // on to an I/O port to gain  
....................            BOOLEAN rs;               // access to the LCD pins.  
....................            BOOLEAN rw;               // The bits are allocated from  
....................            BOOLEAN unused;           // low order up.  ENABLE will  
....................            int     data : 4;         // be pin B0.  
....................         }lcd;  
.................... //struct lcd_pin_map *lcd = 0xF83;  
....................   
.................... //#if defined(__PCH__)  
.................... //#if defined use_portb_lcd  
.................... //   #byte lcd = 0xF81                   // This puts the entire structure  
.................... //#else  
....................    #byte lcd = 0xF83                   // This puts the entire structure  
.................... //#endif  
.................... //#else  
.................... //#if defined use_portb_lcd  
.................... //   #byte lcd = 6                  // on to port B (at address 6)                ????????? 
.................... //#else  
.................... //   #byte lcd = 8                 // on to port D (at address 8)  
.................... //#endif  
.................... //#endif  
....................   
.................... //#if defined use_portb_lcd  
.................... //   #define set_tris_lcd(x) set_tris_b(x)  
.................... //#else  
....................    #define set_tris_lcd(x) set_tris_d(x)  
.................... //#endif  
....................   
....................   
.................... #define lcd_type 3           // 0=5x7, 1=5x10, 2=2 lines, 3=2 lines Disp ON  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line             ?????????? 
....................   
....................   
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0x0f, 0x01, 0x06};  
....................                              // These bytes need to be sent to the LCD  
....................                              // to start it up.  
....................   
....................   
....................                              // The following are used for setting  
....................                              // the I/O port direction register.  
....................   
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out  
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in  
....................   
....................   
....................   
.................... BYTE lcd_read_byte() {  
....................       BYTE low,high;  
....................       set_tris_lcd(LCD_READ);  
*
0560:  MOVLW  F0
0562:  MOVWF  F95
....................       lcd.rw = 1;  
0564:  BSF    F83.2
....................       delay_cycles(1);  
0566:  NOP   
....................       lcd.enable = 1;  
0568:  BSF    F83.0
....................       delay_cycles(1);  
056A:  NOP   
....................       high = lcd.data;  
056C:  SWAPF  F83,W
056E:  ANDLW  0F
0570:  MOVWF  73
....................       lcd.enable = 0;  
0572:  BCF    F83.0
....................       delay_cycles(1);  
0574:  NOP   
....................       lcd.enable = 1;  
0576:  BSF    F83.0
....................       delay_us(1);  
0578:  MOVLW  10
057A:  MOVWF  00
057C:  DECFSZ 00,F
057E:  BRA    057C
0580:  NOP   
....................       low = lcd.data;  
0582:  SWAPF  F83,W
0584:  ANDLW  0F
0586:  MOVWF  72
....................       lcd.enable = 0;  
0588:  BCF    F83.0
....................       set_tris_lcd(LCD_WRITE);  
058A:  MOVLW  00
058C:  MOVWF  F95
....................       return( (high<<4) | low);  
058E:  SWAPF  73,W
0590:  MOVWF  00
0592:  MOVLW  F0
0594:  ANDWF  00,F
0596:  MOVF   00,W
0598:  IORWF  72,W
059A:  MOVWF  01
.................... }  
059C:  GOTO   05A4 (RETURN)
....................   
....................   
.................... void lcd_send_nibble( BYTE n ) {  
....................       lcd.data = n;  
*
0542:  SWAPF  73,W
0544:  ANDLW  F0
0546:  MOVWF  00
0548:  MOVLW  0F
054A:  ANDWF  F83,W
054C:  IORWF  00,W
054E:  MOVWF  F83
....................       delay_cycles(1);  
0550:  NOP   
....................       lcd.enable = 1;  
0552:  BSF    F83.0
....................       delay_us(2);  
0554:  MOVLW  21
0556:  MOVWF  00
0558:  DECFSZ 00,F
055A:  BRA    0558
....................       lcd.enable = 0;  
055C:  BCF    F83.0
.................... }  
055E:  RETLW  00
....................   
....................   
.................... void lcd_send_byte( BYTE address, BYTE n ) {  
....................   
....................       lcd.rs = 0;  
*
05A0:  BCF    F83.1
....................       while ( bit_test(lcd_read_byte(),7) ) ;  
05A2:  BRA    0560
05A4:  MOVFF  01,72
05A8:  BTFSC  01.7
05AA:  BRA    05A2
....................       lcd.rs = address;  
05AC:  BTFSS  70.0
05AE:  BCF    F83.1
05B0:  BTFSC  70.0
05B2:  BSF    F83.1
....................       delay_cycles(1);  
05B4:  NOP   
....................       lcd.rw = 0;  
05B6:  BCF    F83.2
....................       delay_cycles(1);  
05B8:  NOP   
....................       lcd.enable = 0;  
05BA:  BCF    F83.0
....................       lcd_send_nibble(n >> 4);  
05BC:  SWAPF  71,W
05BE:  MOVWF  72
05C0:  MOVLW  0F
05C2:  ANDWF  72,F
05C4:  MOVFF  72,73
05C8:  RCALL  0542
....................       lcd_send_nibble(n & 0xf);  
05CA:  MOVF   71,W
05CC:  ANDLW  0F
05CE:  MOVWF  72
05D0:  MOVFF  72,73
05D4:  RCALL  0542
.................... }  
05D6:  RETLW  00
....................   
....................   
.................... void lcd_init() {  
....................     BYTE i;  
....................     set_tris_lcd(LCD_WRITE);  
05D8:  MOVLW  00
05DA:  MOVWF  F95
....................     delay_ms(45);                                      // modified  
05DC:  MOVLW  2D
05DE:  MOVWF  6C
05E0:  RCALL  051C
....................     lcd.rs = 0;  
05E2:  BCF    F83.1
....................     lcd.rw = 0;  
05E4:  BCF    F83.2
....................     lcd.enable = 0;  
05E6:  BCF    F83.0
....................     //delay_ms(15);                                    // modified  
....................     //for(i=1;i<=3;++i) {                              // modified  
....................     //   lcd_send_nibble(3);                           // modified  
....................     //   delay_ms(5);                                  // modified  
....................     //}                                                // modified  
....................     lcd_send_nibble(2);  
05E8:  MOVLW  02
05EA:  MOVWF  73
05EC:  RCALL  0542
....................     for(i=0;i<=3;++i)  
05EE:  CLRF   59
05F0:  MOVF   59,W
05F2:  SUBLW  03
05F4:  BNC   0610
....................        {                                                // modified  
....................           lcd_send_byte(0,LCD_INIT_STRING[i]);  
05F6:  CLRF   03
05F8:  MOVF   59,W
05FA:  RCALL  0096
05FC:  MOVWF  5A
05FE:  CLRF   70
0600:  MOVFF  5A,71
0604:  RCALL  05A0
....................           delay_ms(5);                                  // modified  
0606:  MOVLW  05
0608:  MOVWF  6C
060A:  RCALL  051C
....................        }                                                // modified  
060C:  INCF   59,F
060E:  BRA    05F0
.................... }  
0610:  GOTO   0E70 (RETURN)
....................   
....................   
.................... void lcd_gotoxy( BYTE x, BYTE y) {  
....................    BYTE address;  
....................   
....................    if(y!=1)  
*
0962:  DECFSZ 6D,W
0964:  BRA    0968
0966:  BRA    096E
....................      address=lcd_line_two;  
0968:  MOVLW  40
096A:  MOVWF  6E
....................    else  
096C:  BRA    0970
....................      address=0;  
096E:  CLRF   6E
....................    address+=x-1;  
0970:  MOVLW  01
0972:  SUBWF  6C,W
0974:  ADDWF  6E,F
....................    lcd_send_byte(0,0x80|address);  
0976:  MOVF   6E,W
0978:  IORLW  80
097A:  MOVWF  6F
097C:  CLRF   70
097E:  MOVFF  6F,71
0982:  RCALL  05A0
.................... }  
0984:  GOTO   09C8 (RETURN)
....................   
.................... void lcd_putc( char c) {  
....................    switch (c) {  
0988:  MOVF   6B,W
098A:  XORLW  0C
098C:  BZ    0998
098E:  XORLW  06
0990:  BZ    09A8
0992:  XORLW  02
0994:  BZ    09B2
0996:  BRA    09BC
....................      case '\f'   : lcd_send_byte(0,1);  
0998:  CLRF   70
099A:  MOVLW  01
099C:  MOVWF  71
099E:  RCALL  05A0
....................                    delay_ms(2);  
09A0:  MOVLW  02
09A2:  MOVWF  6C
09A4:  RCALL  051C
....................                                            break;  
09A6:  BRA    09C8
....................      case '\n'   : lcd_gotoxy(1,2);        break;  
09A8:  MOVLW  01
09AA:  MOVWF  6C
09AC:  MOVLW  02
09AE:  MOVWF  6D
09B0:  BRA    0962
....................      case '\b'   : lcd_send_byte(0,0x10);  break;  
09B2:  CLRF   70
09B4:  MOVLW  10
09B6:  MOVWF  71
09B8:  RCALL  05A0
09BA:  BRA    09C8
....................      default     : lcd_send_byte(1,c);     break;  
09BC:  MOVLW  01
09BE:  MOVWF  70
09C0:  MOVFF  6B,71
09C4:  RCALL  05A0
09C6:  BRA    09C8
....................    }  
.................... }  
09C8:  RETLW  00
....................   
.................... char lcd_getc( BYTE x, BYTE y) {  
....................    char value;  
....................   
....................     lcd_gotoxy(x,y);  
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low  
....................     lcd.rs=1;  
....................     value = lcd_read_byte();  
....................     lcd.rs=0;  
....................     return(value);  
.................... }  
....................  
....................   
....................   
....................   
....................  
....................   
.................... // Function declerations  
.................... int analogPercentage(float analogValue);  
.................... int ananlogKeyDifference(char press, int currentNumber);  
....................   
.................... // Global Variables  
.................... float voltageRange = 6.0;  
.................... //float Vres = 5.0 / 1023.0;  
.................... float Vres = 6.0 / 1023.0;  
.................... float Voltage;  
....................   
.................... #INT_AD  
.................... void int_ad_isr(){  
....................    Voltage = (*ADRESL * Vres) - 3;  
*
0484:  MOVFF  39,03
0488:  MOVFF  38,FE9
048C:  MOVFF  39,FEA
0490:  MOVFF  FEC,76
0494:  MOVF   FED,F
0496:  MOVFF  FEF,75
049A:  MOVFF  76,78
049E:  MOVFF  75,77
04A2:  BRA    00E6
04A4:  MOVFF  03,7A
04A8:  MOVFF  02,79
04AC:  MOVFF  01,78
04B0:  MOVFF  00,77
04B4:  MOVFF  51,7E
04B8:  MOVFF  50,7D
04BC:  MOVFF  4F,7C
04C0:  MOVFF  4E,7B
04C4:  RCALL  0120
04C6:  MOVFF  00,77
04CA:  MOVFF  01,78
04CE:  MOVFF  02,79
04D2:  MOVFF  03,7A
04D6:  MOVFF  FEA,7C
04DA:  MOVFF  FE9,7B
04DE:  BSF    FD8.1
04E0:  MOVFF  03,80
04E4:  MOVFF  02,7F
04E8:  MOVFF  01,7E
04EC:  MOVFF  00,7D
04F0:  CLRF   x84
04F2:  CLRF   x83
04F4:  MOVLW  40
04F6:  MOVWF  x82
04F8:  MOVLW  80
04FA:  MOVWF  x81
04FC:  RCALL  0214
04FE:  MOVFF  7C,FEA
0502:  MOVFF  7B,FE9
0506:  MOVFF  03,55
050A:  MOVFF  02,54
050E:  MOVFF  01,53
0512:  MOVFF  00,52
.................... }  
....................   
0516:  BCF    F9E.6
0518:  GOTO   0054
.................... main(){  
....................      
*
0D6A:  CLRF   FF8
0D6C:  BCF    FD0.7
0D6E:  BSF    0D.7
0D70:  CLRF   FEA
0D72:  CLRF   FE9
0D74:  MOVF   FC1,W
0D76:  ANDLW  C0
0D78:  IORLW  03
0D7A:  MOVWF  FC1
0D7C:  MOVLW  07
0D7E:  MOVWF  FB4
0D80:  MOVF   FB4,W
0D82:  BCF    FA1.6
0D84:  MOVLW  92
0D86:  MOVWF  18
0D88:  MOVLW  0F
0D8A:  MOVWF  19
0D8C:  MOVLW  93
0D8E:  MOVWF  1A
0D90:  MOVLW  0F
0D92:  MOVWF  1B
0D94:  MOVLW  94
0D96:  MOVWF  1C
0D98:  MOVLW  0F
0D9A:  MOVWF  1D
0D9C:  MOVLW  95
0D9E:  MOVWF  1E
0DA0:  MOVLW  0F
0DA2:  MOVWF  1F
0DA4:  MOVLW  96
0DA6:  MOVWF  20
0DA8:  MOVLW  0F
0DAA:  MOVWF  21
0DAC:  MOVLW  80
0DAE:  MOVWF  22
0DB0:  MOVLW  0F
0DB2:  MOVWF  23
0DB4:  MOVLW  81
0DB6:  MOVWF  24
0DB8:  MOVLW  0F
0DBA:  MOVWF  25
0DBC:  MOVLW  82
0DBE:  MOVWF  26
0DC0:  MOVLW  0F
0DC2:  MOVWF  27
0DC4:  MOVLW  83
0DC6:  MOVWF  28
0DC8:  MOVLW  0F
0DCA:  MOVWF  29
0DCC:  MOVLW  84
0DCE:  MOVWF  2A
0DD0:  MOVLW  0F
0DD2:  MOVWF  2B
0DD4:  MOVLW  89
0DD6:  MOVWF  2C
0DD8:  MOVLW  0F
0DDA:  MOVWF  2D
0DDC:  MOVLW  8A
0DDE:  MOVWF  2E
0DE0:  MOVLW  0F
0DE2:  MOVWF  2F
0DE4:  MOVLW  8B
0DE6:  MOVWF  30
0DE8:  MOVLW  0F
0DEA:  MOVWF  31
0DEC:  MOVLW  8C
0DEE:  MOVWF  32
0DF0:  MOVLW  0F
0DF2:  MOVWF  33
0DF4:  MOVLW  8D
0DF6:  MOVWF  34
0DF8:  MOVLW  0F
0DFA:  MOVWF  35
0DFC:  MOVLW  C4
0DFE:  MOVWF  36
0E00:  MOVLW  0F
0E02:  MOVWF  37
0E04:  MOVLW  C3
0E06:  MOVWF  38
0E08:  MOVLW  0F
0E0A:  MOVWF  39
0E0C:  MOVLW  C2
0E0E:  MOVWF  3A
0E10:  MOVLW  0F
0E12:  MOVWF  3B
0E14:  MOVLW  C1
0E16:  MOVWF  3C
0E18:  MOVLW  0F
0E1A:  MOVWF  3D
0E1C:  MOVLW  C0
0E1E:  MOVWF  3E
0E20:  MOVLW  0F
0E22:  MOVWF  3F
0E24:  MOVLW  F2
0E26:  MOVWF  40
0E28:  MOVLW  0F
0E2A:  MOVWF  41
0E2C:  MOVLW  F1
0E2E:  MOVWF  42
0E30:  MOVLW  0F
0E32:  MOVWF  43
0E34:  MOVLW  F0
0E36:  MOVWF  44
0E38:  MOVLW  0F
0E3A:  MOVWF  45
0E3C:  MOVLW  9D
0E3E:  MOVWF  46
0E40:  MOVLW  0F
0E42:  MOVWF  47
0E44:  MOVLW  81
0E46:  MOVWF  48
0E48:  MOVLW  0F
0E4A:  MOVWF  49
0E4C:  MOVLW  81
0E4E:  MOVWF  4A
0E50:  MOVLW  40
0E52:  MOVWF  4B
0E54:  CLRF   4C
0E56:  CLRF   4D
0E58:  MOVLW  77
0E5A:  MOVWF  4E
0E5C:  MOVLW  40
0E5E:  MOVWF  4F
0E60:  MOVLW  30
0E62:  MOVWF  50
0E64:  MOVLW  0C
0E66:  MOVWF  51
....................    unsigned int percentVoltageRange = 0;  
0E68:  CLRF   56
....................    unsigned int currentNumber = 0;  
0E6A:  CLRF   57
....................    char press;  
....................      
....................    lcd_init();  
0E6C:  GOTO   05D8
....................   
....................    ADCON0->ADON = 1;  
0E70:  MOVFF  3A,FE9
0E74:  MOVFF  3B,FEA
0E78:  BSF    FEF.0
....................    ADCON0->CHSx = 0;  
0E7A:  MOVFF  3A,FE9
0E7E:  MOVFF  3B,FEA
0E82:  MOVLW  C3
0E84:  ANDWF  FEF,W
0E86:  MOVWF  FEF
....................    ADCON1->PCFGX = 8;  
0E88:  MOVFF  3C,FE9
0E8C:  MOVFF  3D,FEA
0E90:  MOVLW  F0
0E92:  ANDWF  FEF,W
0E94:  IORLW  08
0E96:  MOVWF  FEF
....................   
....................    *TRISA = 0x01;  // set A0 as input  
0E98:  MOVFF  18,FE9
0E9C:  MOVFF  19,FEA
0EA0:  MOVLW  01
0EA2:  MOVWF  FEF
....................   
....................    ADCON2->ADFM = 1; // right justify  
0EA4:  MOVFF  3E,FE9
0EA8:  MOVFF  3F,FEA
0EAC:  BSF    FEF.7
....................   
....................    // enable references  
....................    ADCON1->VCFG0 = 1;  
0EAE:  MOVFF  3C,FE9
0EB2:  MOVFF  3D,FEA
0EB6:  BSF    FEF.4
....................    ADCON1->VCFG1 = 1;  
0EB8:  MOVFF  3C,FE9
0EBC:  MOVFF  3D,FEA
0EC0:  BSF    FEF.5
....................   
....................   
....................    // interrupt setup  
....................    PIE1->ADIE = 1;  
0EC2:  MOVFF  46,FE9
0EC6:  MOVFF  47,FEA
0ECA:  BSF    FEF.6
....................    INTCON->GIE = 1;  
0ECC:  MOVFF  40,FE9
0ED0:  MOVFF  41,FEA
0ED4:  BSF    FEF.7
....................    INTCON->PEIE = 1;  
0ED6:  MOVFF  40,FE9
0EDA:  MOVFF  41,FEA
0EDE:  BSF    FEF.6
....................   
....................    *TRISB = 0xF0;  
0EE0:  MOVFF  1A,FE9
0EE4:  MOVFF  1B,FEA
0EE8:  MOVLW  F0
0EEA:  MOVWF  FEF
....................    *TRISC = 0x00;  
0EEC:  MOVFF  1C,FE9
0EF0:  MOVFF  1D,FEA
0EF4:  CLRF   FEF
....................    ADCON1->PCFGx = 0x0F;  
0EF6:  MOVFF  3C,FE9
0EFA:  MOVFF  3D,FEA
0EFE:  MOVLW  F0
0F00:  ANDWF  FEF,W
0F02:  IORLW  0F
0F04:  MOVWF  FEF
....................    INTCON2->RBPU = 0;  
0F06:  MOVFF  42,FE9
0F0A:  MOVFF  43,FEA
0F0E:  BCF    FEF.7
....................   
....................    while(1){  
....................   
....................       ADCON0->GODONE = 1;  
0F10:  MOVFF  3A,FE9
0F14:  MOVFF  3B,FEA
0F18:  BSF    FEF.1
....................   
....................       press = keyPress();  
0F1A:  GOTO   0614
0F1E:  MOVFF  01,58
....................   
....................       percentVoltageRange = analogPercentage(Voltage);  
0F22:  MOVFF  55,5C
0F26:  MOVFF  54,5B
0F2A:  MOVFF  53,5A
0F2E:  MOVFF  52,59
0F32:  BRA    089A
0F34:  MOVFF  01,56
....................         
....................   
....................       if( press != defaultPress){  
0F38:  MOVF   58,W
0F3A:  SUBLW  20
0F3C:  BZ    0FD0
....................         
....................             currentNumber = ananlogKeyDifference(press, currentNumber);  
0F3E:  MOVFF  58,59
0F42:  MOVFF  57,5A
0F46:  BRA    094C
0F48:  MOVFF  01,57
....................               
....................             printf(lcd_putc, "\fV:%03.4fV KP:%c\nP:%d\t\t\t\t%i", Voltage, press, percentVoltageRange, currentNumber);  
0F4C:  MOVLW  0C
0F4E:  MOVWF  6B
0F50:  RCALL  0988
0F52:  MOVLW  56
0F54:  MOVWF  6B
0F56:  RCALL  0988
0F58:  MOVLW  3A
0F5A:  MOVWF  6B
0F5C:  RCALL  0988
0F5E:  MOVFF  55,5C
0F62:  MOVFF  54,5B
0F66:  MOVFF  53,5A
0F6A:  MOVFF  52,59
0F6E:  CLRF   60
0F70:  CLRF   5F
0F72:  MOVLW  01
0F74:  MOVWF  5E
0F76:  MOVLW  84
0F78:  MOVWF  5D
0F7A:  BRA    09CA
0F7C:  MOVLW  09
0F7E:  MOVWF  59
0F80:  MOVF   59,W
0F82:  CALL   00B4
0F86:  INCF   59,F
0F88:  MOVWF  00
0F8A:  MOVFF  00,6B
0F8E:  RCALL  0988
0F90:  MOVLW  0E
0F92:  SUBWF  59,W
0F94:  BNZ   0F80
0F96:  MOVFF  58,6B
0F9A:  RCALL  0988
0F9C:  MOVLW  0A
0F9E:  MOVWF  6B
0FA0:  RCALL  0988
0FA2:  MOVLW  50
0FA4:  MOVWF  6B
0FA6:  RCALL  0988
0FA8:  MOVLW  3A
0FAA:  MOVWF  6B
0FAC:  RCALL  0988
0FAE:  MOVFF  56,5B
0FB2:  MOVLW  18
0FB4:  MOVWF  5C
0FB6:  RCALL  0CC4
0FB8:  MOVLW  04
0FBA:  MOVWF  5A
0FBC:  MOVLW  09
0FBE:  MOVWF  6B
0FC0:  RCALL  0988
0FC2:  DECFSZ 5A,F
0FC4:  BRA    0FBC
0FC6:  MOVFF  57,5B
0FCA:  MOVLW  18
0FCC:  MOVWF  5C
0FCE:  RCALL  0CC4
....................       }  
....................         
....................       delay_ms(10);  
0FD0:  MOVLW  0A
0FD2:  MOVWF  6C
0FD4:  CALL   051C
....................    }  
0FD8:  BRA    0F10
.................... }  
....................   
.................... // Function definitions  
....................   
.................... int analogPercentage(float analogValue){  
....................       return(((analogValue+3)/voltageRange)*100);  
*
089A:  BCF    FD8.1
089C:  CLRF   17
089E:  BTFSC  FF2.7
08A0:  BSF    17.7
08A2:  BCF    FF2.7
08A4:  MOVFF  5C,80
08A8:  MOVFF  5B,7F
08AC:  MOVFF  5A,7E
08B0:  MOVFF  59,7D
08B4:  CLRF   x84
08B6:  CLRF   x83
08B8:  MOVLW  40
08BA:  MOVWF  x82
08BC:  MOVLW  80
08BE:  MOVWF  x81
08C0:  RCALL  0214
08C2:  BTFSC  17.7
08C4:  BSF    FF2.7
08C6:  MOVFF  00,5D
08CA:  MOVFF  01,5E
08CE:  MOVFF  02,5F
08D2:  MOVFF  03,60
08D6:  MOVFF  03,64
08DA:  MOVFF  02,63
08DE:  MOVFF  01,62
08E2:  MOVFF  00,61
08E6:  MOVFF  4D,68
08EA:  MOVFF  4C,67
08EE:  MOVFF  4B,66
08F2:  MOVFF  4A,65
08F6:  BRA    06FE
08F8:  MOVFF  00,61
08FC:  MOVFF  01,62
0900:  MOVFF  02,63
0904:  MOVFF  03,64
0908:  CLRF   17
090A:  BTFSC  FF2.7
090C:  BSF    17.7
090E:  BCF    FF2.7
0910:  MOVFF  03,7A
0914:  MOVFF  02,79
0918:  MOVFF  01,78
091C:  MOVFF  00,77
0920:  CLRF   7E
0922:  CLRF   7D
0924:  MOVLW  48
0926:  MOVWF  7C
0928:  MOVLW  85
092A:  MOVWF  7B
092C:  CALL   0120
0930:  BTFSC  17.7
0932:  BSF    FF2.7
0934:  MOVFF  03,68
0938:  MOVFF  02,67
093C:  MOVFF  01,66
0940:  MOVFF  00,65
0944:  BRA    085E
0946:  MOVF   01,W
*
0FDA:  SLEEP 
.................... }  
*
0948:  GOTO   0F34 (RETURN)
....................   
.................... int ananlogKeyDifference(char press, int currentNumber){  
....................       int keypadNumber;  
....................       int newNumber;  
....................       keypadNumber = press-0x30;  
094C:  MOVLW  30
094E:  SUBWF  59,W
0950:  MOVWF  5B
....................       newNumber = currentNumber;  
0952:  MOVFF  5A,5C
....................       /*if (keypadNumber >= 0 && keypadNumber <= 10){  
....................         
....................             newNumber = (currentNumber*10)+keypadNumber;  
....................               
....................             /*if (currentNumber >= 10){  
....................                   newNumber  
....................                   newNumber = (currentNumber*10)+keypadNumber;       
....................             }  
....................             else{  
....................                   newNumber = currentNumber + keypadNumber;       
....................             }  
....................       }  
....................       else{  
....................             newNumber = 0;  
....................       }*/  
....................       currentNumber = currentNumber + keypadNumber;  
0956:  MOVF   5B,W
0958:  ADDWF  5A,F
....................       return(currentNumber);    
095A:  MOVFF  5A,01
.................... }  
095E:  GOTO   0F48 (RETURN)
....................   
....................   
....................  

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 1E0F   BROWNOUT NOWDT BORV25 NOPUT WDT32768
   Word  3: 8700   PBADEN CCP2C1 LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
