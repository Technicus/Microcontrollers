CCS PCH C Compiler, Version 3.202, 16465

               Filename: E:\Microcontrollers\Code-Design\Code\Keypad\keypadtest.LST

               ROM used: 924 bytes (3%)
                         Largest free fragment is 31844
               RAM used: 58 (4%) at main() level
                         66 (4%) worst case
               Stack:    4 locations

*
0000:  GOTO   026A
....................  /* Initial lcd test  
....................    2015-.09.24  
....................    ../../designs/LCDpanel_1.design  
.................... */  
....................   
.................... #include <18f452.h> 
....................  //////// Standard Header file for the PIC18F452 device ////////////////  
.................... #device PIC18F452  
.................... #list  
....................  
.................... #use delay (clock = 200000000)  
0018:  CLRF   FEA
001A:  MOVLW  39
001C:  MOVWF  FE9
001E:  MOVF   FEF,W
0020:  BZ    003C
0022:  MOVLW  40
0024:  MOVWF  01
0026:  CLRF   00
0028:  DECFSZ 00,F
002A:  BRA    0028
002C:  DECFSZ 01,F
002E:  BRA    0026
0030:  MOVLW  D9
0032:  MOVWF  00
0034:  DECFSZ 00,F
0036:  BRA    0034
0038:  DECFSZ FEF,F
003A:  BRA    0022
003C:  RETLW  00
.................... #fuses HS, NOWDT, NOLvP  
.................... #include "../Library/Library_18f4520.h" 
....................  /*  
....................  * Library_18f4520.h  
....................  *  
....................  *  
....................  */  
....................   
....................   
.................... // All register addresses are defined as: #define REGISTER_<name-of-register> <hex-of-address>  
.................... #include "../library/Register_Addresses_Definitions.h" 
....................  /*   
....................  * Register_Addresses_Definitions.h  
....................  *   
....................  * Register addresses  
....................  * 	The addresses are all defined as:  
....................  * 		#define REGISTER_<name-of-register> <hex-of-address>  
....................  *   
....................  * Notes:  
....................  * 	1: This is not a physical register.  
....................  * 	2: Unimplemented registers are read as ‘0’.  
....................  * 	3: This register is not available on 28-pin devices.  
....................  *   
....................  */  
....................   
.................... #define REGISTER_TOSU 0xFFF               // Comments needed  
.................... #define REGISTER_TOSH 0xFFE               // Comments needed  
.................... #define REGISTER_TOSL 0xFFD               // Comments needed  
....................                                                
.................... #define REGISTER_STKPTR 0xFFC             // Comments needed  
....................                                                
.................... #define REGISTER_PCLATU 0xFFB             // Comments needed  
.................... #define REGISTER_PCLATH 0xFFA             // Comments needed  
.................... #define REGISTER_PCL 0xFF9                // Comments needed  
....................                                               
.................... #define REGISTER_TBLPTRU 0xFF8            // Comments needed  
.................... #define REGISTER_TBLPTRH 0xFF7            // Comments needed  
.................... #define REGISTER_TBLPTRL 0xFF6            // Comments needed  
.................... #define REGISTER_TABLAT 0xFF5             // Comments needed  
....................                                                
.................... #define REGISTER_PRODH 0xFF4              // Comments needed  
.................... #define REGISTER_PRODL 0xFF3              // Comments needed  
....................                                                
.................... #define REGISTER_INTCON 0xFF2             // Comments needed  
.................... #define REGISTER_INTCON2 0xFF1            // Comments needed  
.................... #define REGISTER_INTCON3 0xFF0            // Comments needed  
.................... #define REGISTER_INDF0 0xFEF              // 1: This is not a physical register.  
....................   
.................... #define REGISTER_POSTINC0 0xFEE           // 1: This is not a physical register.  
.................... #define REGISTER_POSTDEC0 0xFED           // 1: This is not a physical register.  
.................... #define REGISTER_PREINC0 0xFEC            // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PLUSW0 0xFEB             // 1: This is not a physical register.  
....................   
.................... #define REGISTER_FSR0H 0xFEA              // Comments needed  
.................... #define REGISTER_FSR0L 0xFE9              // Comments needed  
....................   
.................... #define REGISTER_WREG 0xFE8               // Comments needed  
....................   
.................... #define REGISTER_INDF1 0xFE7              // 1: This is not a physical register.  
....................   
.................... #define REGISTER_POSTINC1 0xFE6           // 1: This is not a physical register.  
.................... #define REGISTER_POSTDEC1 0xFE5           // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PREINC1 0xFE4            // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PLUSW1 0xFE3             // 1: This is not a physical register.  
....................   
.................... #define REGISTER_FSR1H 0xFE2              // Comments needed  
.................... #define REGISTER_FSR1L 0xFE1              // Comments needed  
....................   
.................... #define REGISTER_BSR 0xFE0                // Comments needed  
....................   
.................... #define REGISTER_INDF2 0xFDF              // 1: This is not a physical register.  
....................   
.................... #define REGISTER_POSTINC2 0xFDE           // 1: This is not a physical register.  
.................... #define REGISTER_POSTDEC2 0xFDD           // 1: This is not a physical register.  
.................... #define REGISTER_PREINC2 0xFDC            // 1: This is not a physical register.  
....................   
.................... #define REGISTER_PLUSW2 0xFDB             // 1: This is not a physical register.  
....................   
.................... #define REGISTER_FSR2H 0xFDA              // Comments needed  
.................... #define REGISTER_FSR2L 0xFD9              // Comments needed  
....................   
.................... #define REGISTER_STATUS 0xFD8             // Comments needed  
....................   
.................... #define REGISTER_TMR0H 0xFD7              // Comments needed  
.................... #define REGISTER_TMR0L 0xFD6              // Comments needed  
.................... #define REGISTER_T0CON 0xFD5              // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_0 0xFD4    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_OSCCON 0xFD3             // Comments needed  
....................   
.................... #define REGISTER_HLVDCON 0xFD2            // Comments needed  
....................   
.................... #define REGISTER_WDTCON 0xFD1             // Comments needed  
....................   
.................... #define REGISTER_RCON 0xFD0               // Comments needed  
....................   
.................... #define REGISTER_TMR1H 0xFCF              // Comments needed  
.................... #define REGISTER_TMR1L 0xFCE              // Comments needed  
.................... #define REGISTER_T1CON 0xFCD              // Comments needed  
.................... #define REGISTER_TMR2 0xFCC               // Comments needed  
....................   
.................... #define REGISTER_PR2 0xFCB                // Comments needed  
....................   
.................... #define REGISTER_T2CON 0xFCA              // Comments needed  
....................   
.................... #define REGISTER_SSPBUF 0xFC9             // Comments needed  
.................... #define REGISTER_SSPADD 0xFC8             // Comments needed  
.................... #define REGISTER_SSPSTAT 0xFC7            // Comments needed  
.................... #define REGISTER_SSPCON1 0xFC6            // Comments needed  
.................... #define REGISTER_SSPCON2 0xFC5            // Comments needed  
....................   
.................... #define REGISTER_ADRESH 0xFC4             // Comments needed  
.................... #define REGISTER_ADRESL 0xFC3             // Comments needed  
.................... #define REGISTER_ADCON0 0xFC2             // Comments needed  
.................... #define REGISTER_ADCON1 0xFC1             // Comments needed  
.................... #define REGISTER_ADCON2 0xFC0             // Comments needed  
....................   
.................... #define REGISTER_CCPR1H 0xFBF             // Comments needed  
.................... #define REGISTER_CCPR1L 0xFBE             // Comments needed  
.................... #define REGISTER_CCP1CON 0xFBD            // Comments needed  
.................... #define REGISTER_CCPR2H 0xFBC             // Comments needed  
.................... #define REGISTER_CCPR2L 0xFBB             // Comments needed  
.................... #define REGISTER_CCP2CON 0xFBA            // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_1 0xFB9    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_BAUDCON 0xFB8            // Comments needed  
....................   
.................... #define REGISTER_PWM1CON 0xFB7            // 3: This register is not available on 28-pin devices.  
....................   
.................... #define REGISTER_ECCP1AS 0xFB6            // 3: This register is not available on 28-pin devices.  
....................   
.................... #define REGISTER_CVRCON 0xFB5             // Comments needed  
.................... #define REGISTER_CMCON 0xFB4              // Comments needed  
.................... #define REGISTER_TMR3H 0xFB3              // Comments needed  
.................... #define REGISTER_TMR3L 0xFB2              // Comments needed  
.................... #define REGISTER_T3CON 0xFB1              // Comments needed  
....................   
.................... #define REGISTER_SPBRGH 0xFB0             // Comments needed  
.................... #define REGISTER_SPBRG 0xFAF              // Comments needed  
.................... #define REGISTER_RCREG 0xFAE              // Comments needed  
....................   
.................... #define REGISTER_TXREG 0xFAD              // Comments needed  
.................... #define REGISTER_TXSTA 0xFAC              // Comments needed  
.................... #define REGISTER_RCSTA 0xFAB              // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_2 0xFAA    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_EEADR 0xFA9              // Comments needed  
.................... #define REGISTER_EEDATA 0xFA8             // Comments needed  
.................... #define REGISTER_EECON2 0xFA7             // 1: This is not a physical register.  
.................... #define REGISTER_EECON1 0xFA6             // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_3 0xFA5    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_4 0xFA4    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_5 0xFA3    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_IPR2 0xFA2               // Comments needed  
.................... #define REGISTER_PIR2 0xFA1               // Comments needed  
.................... #define REGISTER_PIE2 0xFA0               // Comments needed  
.................... #define REGISTER_IPR1 0xF9F               // Comments needed  
.................... #define REGISTER_PIR1 0xF9E               // Comments needed  
.................... #define REGISTER_PIE1 0xF9D               // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_6 0xF9C    // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_OSCTUNE 0xF9B            // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_7 0xF9A    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_8 0xF99    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_9 0xF98    // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_10 0xF97   // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_TRISE 0xF96              // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_TRISD 0xF95              // Comments needed  
.................... #define REGISTER_TRISC 0xF94              // Comments needed  
.................... #define REGISTER_TRISB 0xF93              // Comments needed  
.................... #define REGISTER_TRISA 0xF92              // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_11 0xF91   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_12 0xF90   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_13 0xF8F   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_14 0xF8E   // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_LATE 0xF8D               // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_LATD 0xF8C               // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_LATC 0xF8B               // Comments needed  
.................... #define REGISTER_LATB 0xF8A               // Comments needed  
.................... #define REGISTER_LATA 0xF89               // Comments needed  
....................   
.................... #define REGISTER_UNIMPLEMENTED_15 0xF88   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_16 0xF87   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_17 0xF86   // 2: Unimplemented registers are read as ‘0’.  
.................... #define REGISTER_UNIMPLEMENTED_18 0xF85   // 2: Unimplemented registers are read as ‘0’.  
....................   
.................... #define REGISTER_PORTE 0xF84              // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_PORTD 0xF83              // 3: This register is not available on 28-pin devices.  
.................... #define REGISTER_PORTC 0xF82              // Comments needed  
.................... #define REGISTER_PORTB 0xF81              // Comments needed  
.................... #define REGISTER_PORTA 0xF80              // Comments needed  
....................  
....................   
.................... // Pointers to TRIS PORT and LAT registers  
.................... #include "../library/TRIS_PORT_LAT.h" 
....................  /*   
....................  * TRIS_PORT_LAT.h  
....................  *   
....................  * GPIO  
....................  *   
....................  */  
....................   
.................... int *TRISA = REGISTER_TRISA;  
.................... int *TRISB = REGISTER_TRISB;  
.................... int *TRISC = REGISTER_TRISC;  
.................... int *TRISD = REGISTER_TRISD;  
.................... int *TRISE = REGISTER_TRISE;  
....................   
.................... int *PORTA = REGISTER_PORTA;  
.................... int *PORTB = REGISTER_PORTB;  
.................... int *PORTC = REGISTER_PORTC;  
.................... int *PORTD = REGISTER_PORTD;  
.................... int *PORTE = REGISTER_PORTE;  
....................   
.................... int *LATA = REGISTER_LATA;  
.................... int *LATB = REGISTER_LATB;  
.................... int *LATC = REGISTER_LATC;  
.................... int *LATD = REGISTER_LATD;  
.................... int *LATE = REGISTER_LATE; 
....................   
.................... // Structures for analog to digital circuits and defins for Q and L  
.................... #include "../library/Analog_To_Digital.h" 
....................  /*  
....................  * Analog_To_Digital.h  
....................  *   
....................  * Analog to digital circuit connections  
....................  *   
....................  */  
....................   
.................... #define L *ADRESH  
.................... #define Q *ADRESL  
....................   
.................... int16 *ADRESH = REGISTER_ADRESH;  
.................... int16 *ADRESL = REGISTER_ADRESL;  
....................   
.................... struct ADCON_0{  
....................    int ADON:1;  
....................    int GODONE:1;  
....................    int CHSx:4;  
....................    int unused:2;  
.................... };  
.................... struct ADCON_0 *ADCON0 = REGISTER_ADCON0;  
....................   
.................... struct ADCON_1{  
....................    int PCFGx:4;  
....................    int VCFG0:1;  
....................    int VCFG1:1;  
....................    int unused:2;  
.................... };  
.................... struct ADCON_1 *ADCON1 = REGISTER_ADCON1;  
....................   
.................... struct ADCON_2{  
....................    int ADCSx:3;  
....................    int ACQTx:3;  
....................    int unused:1;  
....................    int ADFM:1;  
.................... };  
.................... struct ADCON_2 *ADCON2 = REGISTER_ADCON2;  
....................  
....................   
.................... // Structures for interrupt curcuits  
.................... #include "../library/Interrupts.h" 
....................  /*   
....................  * Interrupts.h  
....................  *   
....................  * External interrupt control  
....................  *   
....................  */  
....................   
.................... struct INTCON_{  
.................... 	int RBIF:1;  
.................... 	int INT0IF:1;  
.................... 	int TMR0IF:1;  
.................... 	int RBIE:1;  
.................... 	int INT0IE:1;  
.................... 	int TMR0IE:1;  
.................... 	int PEIE:1;  
.................... 	int GIE:1;  
.................... 	};  
.................... struct INTCON_ *INTCON = REGISTER_INTCON;  
....................   
.................... struct INTCON_2{  
.................... 	int RBIP:1;  
.................... 	int UNIMPLEMENTED_0:1;  
.................... 	int TMROIP:1;  
.................... 	int UNIMPLEMENTED_1:1;  
.................... 	int INTEDG2:1;  
.................... 	int INTEDG1:1;  
.................... 	int INTEDG0:1;  
.................... 	int RBPU:1;  
.................... 	};  
.................... struct INTCON_2 *INTCON2 = REGISTER_INTCON2;  
....................   
.................... struct INTCON_3{  
.................... 	int INT1F:1;  
.................... 	int INT2F:1;  
.................... 	int UNIMPLEMENTED_0:1;  
.................... 	int INT1E:1;  
.................... 	int INT2E:1;  
.................... 	int UNIMPLEMENTED_1:1;  
.................... 	int INT1P:1;  
.................... 	int INT2P:1;  
.................... 	};  
.................... struct INTCON_3 *INTCON3 = REGISTER_INTCON3;  
....................   
.................... /*  
....................  *   
....................  * Peripheral Interrupts Control Registers  
....................  *   
....................  */  
....................   
.................... struct PIE_1{  
.................... 	int TMR1IE:1;  
.................... 	int TMR2IE:1;  
.................... 	int CCP1IE:1;  
.................... 	int SSPIE:1;  
.................... 	int TXIE:1;  
.................... 	int RCIE:1;  
.................... 	int ADIE:1;  
.................... 	int PSPIE:1;  
.................... 	};  
.................... struct PIE_1 *PIE1 = REGISTER_PIE1;  
....................  
....................   
.................... // Custom libraries for keypad and LCD connections  
.................... #include "../library/Keypad_Connection.h" 
....................  /*  
....................  * Keypad_Connection.h   
....................  *   
....................  * Keypad Connection to PORTB  
....................  *   
....................  */  
....................   
.................... // Coloum references  
.................... #define C0 0x3  
.................... #define C1 0x5  
.................... #define C2 0x6  
....................   
.................... // Row references  
.................... #define R0 0xE  
.................... #define R1 0xD  
.................... #define R2 0xB  
.................... #define R3 0x7  
....................   
.................... struct KeypadConnection{  
....................    int COL:3;  
....................    int unused:1;  
....................    int ROW:4;  
.................... };  
.................... struct KeypadConnection *KEYPAD = REGISTER_PORTB; // PORTB  
....................   
.................... // Declarations  
.................... char keyPress(void);  
....................   
.................... // Definitions  
.................... char keyPress(void){  
....................    char press = '@';  
*
0118:  MOVLW  40
011A:  MOVWF  38
....................   
....................    KEYPAD->COL=C0;  
011C:  MOVF   35,W
011E:  MOVWF  FE9
0120:  MOVF   36,W
0122:  MOVWF  FEA
0124:  MOVLW  F8
0126:  ANDWF  FEF,W
0128:  IORLW  03
012A:  MOVWF  FEF
....................    switch(KEYPAD->ROW){  
012C:  MOVF   35,W
012E:  MOVWF  FE9
0130:  MOVF   36,W
0132:  MOVWF  FEA
0134:  MOVF   FEF,W
0136:  MOVWF  00
0138:  SWAPF  00,W
013A:  ANDLW  0F
013C:  XORLW  0E
013E:  BZ    014E
0140:  XORLW  03
0142:  BZ    0154
0144:  XORLW  06
0146:  BZ    015A
0148:  XORLW  0C
014A:  BZ    0160
014C:  BRA    0166
....................       case R0:  
....................          press = '1';  
014E:  MOVLW  31
0150:  MOVWF  38
....................          break;  
0152:  BRA    0166
....................       case R1:  
....................          press = '4';  
0154:  MOVLW  34
0156:  MOVWF  38
....................          break;  
0158:  BRA    0166
....................       case R2:  
....................          press = '7';  
015A:  MOVLW  37
015C:  MOVWF  38
....................          break;  
015E:  BRA    0166
....................       case R3:  
....................          press = '*';  
0160:  MOVLW  2A
0162:  MOVWF  38
....................          break;  
0164:  BRA    0166
....................       default:  
....................    }  
....................   
....................    KEYPAD->COL=C1;  
0166:  MOVF   35,W
0168:  MOVWF  FE9
016A:  MOVF   36,W
016C:  MOVWF  FEA
016E:  MOVLW  F8
0170:  ANDWF  FEF,W
0172:  IORLW  05
0174:  MOVWF  FEF
....................    switch(KEYPAD->ROW){  
0176:  MOVF   35,W
0178:  MOVWF  FE9
017A:  MOVF   36,W
017C:  MOVWF  FEA
017E:  MOVF   FEF,W
0180:  MOVWF  00
0182:  SWAPF  00,W
0184:  ANDLW  0F
0186:  XORLW  0E
0188:  BZ    0198
018A:  XORLW  03
018C:  BZ    019E
018E:  XORLW  06
0190:  BZ    01A4
0192:  XORLW  0C
0194:  BZ    01AA
0196:  BRA    01B0
....................       case R0:  
....................          press = '2';  
0198:  MOVLW  32
019A:  MOVWF  38
....................          break;  
019C:  BRA    01B0
....................       case R1:  
....................          press = '5';  
019E:  MOVLW  35
01A0:  MOVWF  38
....................          break;  
01A2:  BRA    01B0
....................       case R2:  
....................          press = '8';  
01A4:  MOVLW  38
01A6:  MOVWF  38
....................          break;  
01A8:  BRA    01B0
....................       case R3:  
....................          press = '0';  
01AA:  MOVLW  30
01AC:  MOVWF  38
....................          break;  
01AE:  BRA    01B0
....................       default:  
....................    }  
....................   
....................    KEYPAD->COL=C2;  
01B0:  MOVF   35,W
01B2:  MOVWF  FE9
01B4:  MOVF   36,W
01B6:  MOVWF  FEA
01B8:  MOVLW  F8
01BA:  ANDWF  FEF,W
01BC:  IORLW  06
01BE:  MOVWF  FEF
....................    switch(KEYPAD->ROW){  
01C0:  MOVF   35,W
01C2:  MOVWF  FE9
01C4:  MOVF   36,W
01C6:  MOVWF  FEA
01C8:  MOVF   FEF,W
01CA:  MOVWF  00
01CC:  SWAPF  00,W
01CE:  ANDLW  0F
01D0:  XORLW  0E
01D2:  BZ    01E2
01D4:  XORLW  03
01D6:  BZ    01E8
01D8:  XORLW  06
01DA:  BZ    01EE
01DC:  XORLW  0C
01DE:  BZ    01F4
01E0:  BRA    01FA
....................       case R0:  
....................          press = '3';  
01E2:  MOVLW  33
01E4:  MOVWF  38
....................          break;  
01E6:  BRA    01FA
....................       case R1:  
....................          press = '6';  
01E8:  MOVLW  36
01EA:  MOVWF  38
....................          break;  
01EC:  BRA    01FA
....................       case R2:  
....................          press = '9';  
01EE:  MOVLW  39
01F0:  MOVWF  38
....................          break;  
01F2:  BRA    01FA
....................       case R3:  
....................          press = '#';  
01F4:  MOVLW  23
01F6:  MOVWF  38
....................          break;  
01F8:  BRA    01FA
....................       default:  
....................    }  
....................   
....................    return(press);  
01FA:  MOVF   38,W
01FC:  MOVWF  01
.................... }  
01FE:  GOTO   0376 (RETURN)
....................  
.................... #include "../library/Modified_LCD.h" 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////                             Modified LCD.C                        ////  
.................... ////                 Driver for common LCD modules                     ////  
.................... ////                                                                   ////  
.................... ////  lcd_init()   Must be called before any other function.           ////  
.................... ////         ***This function was modified to fit the Samsumgs6A0069   ////  
.................... ////                                                                   ////  
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     ////  
.................... ////                     The following have special meaning:           ////  
.................... ////                      \f  Clear display                            ////  
.................... ////                      \n  Go to start of second line               ////  
.................... ////                      \b  Move back one position                   ////  
.................... ////                                                                   ////  
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    ////  
.................... ////                                                                   ////  
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         ////  
.................... ////                                                                   ////  
.................... ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... // As defined in the following structure the pin connection is as follows:  
.................... //     D0  enable  
.................... //     D1  rs  
.................... //     D2  rw  
.................... //     D4  D4  
.................... //     D5  D5  
.................... //     D6  D6  
.................... //     D7  D7  
.................... //  
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used.  
....................   
.................... // Un-comment the following define to use port B  
.................... #define use_portb_lcd FALSE  
....................   
.................... // Function declerations  
.................... char lcd_getc( BYTE x, BYTE y);  
.................... void lcd_putc( char c);  
.................... void lcd_gotoxy( BYTE x, BYTE y);  
.................... void lcd_init();  
.................... void lcd_send_byte( BYTE address, BYTE n );  
.................... void lcd_send_nibble( BYTE n );  
.................... BYTE lcd_read_byte();  
....................   
....................   
....................   
.................... struct lcd_pin_map {                 // This structure is overlayed  
....................            BOOLEAN enable;           // on to an I/O port to gain  
....................            BOOLEAN rs;               // access to the LCD pins.  
....................            BOOLEAN rw;               // The bits are allocated from  
....................            BOOLEAN unused;           // low order up.  ENABLE will  
....................            int     data : 4;         // be pin B0.  
....................         }lcd;  
.................... //struct lcd_pin_map *lcd = 0xF83;  
....................   
.................... //#if defined(__PCH__)  
.................... //#if defined use_portb_lcd  
.................... //   #byte lcd = 0xF81                   // This puts the entire structure  
.................... //#else  
....................    #byte lcd = 0xF83                   // This puts the entire structure  
.................... //#endif  
.................... //#else  
.................... //#if defined use_portb_lcd  
.................... //   #byte lcd = 6                  // on to port B (at address 6)                ????????? 
.................... //#else  
.................... //   #byte lcd = 8                 // on to port D (at address 8)  
.................... //#endif  
.................... //#endif  
....................   
.................... //#if defined use_portb_lcd  
.................... //   #define set_tris_lcd(x) set_tris_b(x)  
.................... //#else  
....................    #define set_tris_lcd(x) set_tris_d(x)  
.................... //#endif  
....................   
....................   
.................... #define lcd_type 3           // 0=5x7, 1=5x10, 2=2 lines, 3=2 lines Disp ON  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line             ?????????? 
....................   
....................   
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0x0f, 0x01, 0x06};  
....................                              // These bytes need to be sent to the LCD  
....................                              // to start it up.  
....................   
....................   
....................                              // The following are used for setting  
....................                              // the I/O port direction register.  
....................   
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out  
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in  
....................   
....................   
....................   
.................... BYTE lcd_read_byte() {  
....................       BYTE low,high;  
....................       set_tris_lcd(LCD_READ);  
*
005C:  MOVLW  F0
005E:  MOVWF  F95
....................       lcd.rw = 1;  
0060:  BSF    F83.2
....................       delay_cycles(1);  
0062:  NOP   
....................       lcd.enable = 1;  
0064:  BSF    F83.0
....................       delay_cycles(1);  
0066:  NOP   
....................       high = lcd.data;  
0068:  MOVF   F83,W
006A:  MOVWF  00
006C:  SWAPF  00,W
006E:  ANDLW  0F
0070:  MOVWF  40
....................       lcd.enable = 0;  
0072:  BCF    F83.0
....................       delay_cycles(1);  
0074:  NOP   
....................       lcd.enable = 1;  
0076:  BSF    F83.0
....................       delay_us(1);  
0078:  MOVLW  10
007A:  MOVWF  00
007C:  DECFSZ 00,F
007E:  BRA    007C
0080:  NOP   
....................       low = lcd.data;  
0082:  MOVF   F83,W
0084:  MOVWF  00
0086:  SWAPF  00,W
0088:  ANDLW  0F
008A:  MOVWF  3F
....................       lcd.enable = 0;  
008C:  BCF    F83.0
....................       set_tris_lcd(LCD_WRITE);  
008E:  MOVLW  00
0090:  MOVWF  F95
....................       return( (high<<4) | low);  
0092:  SWAPF  40,W
0094:  MOVWF  00
0096:  MOVLW  F0
0098:  ANDWF  00,F
009A:  MOVF   00,W
009C:  IORWF  3F,W
009E:  MOVWF  01
.................... }  
00A0:  GOTO   00A8 (RETURN)
....................   
....................   
.................... void lcd_send_nibble( BYTE n ) {  
....................       lcd.data = n;  
*
003E:  SWAPF  40,W
0040:  ANDLW  F0
0042:  MOVWF  00
0044:  MOVLW  0F
0046:  ANDWF  F83,W
0048:  IORWF  00,W
004A:  MOVWF  F83
....................       delay_cycles(1);  
004C:  NOP   
....................       lcd.enable = 1;  
004E:  BSF    F83.0
....................       delay_us(2);  
0050:  MOVLW  21
0052:  MOVWF  00
0054:  DECFSZ 00,F
0056:  BRA    0054
....................       lcd.enable = 0;  
0058:  BCF    F83.0
.................... }  
005A:  RETLW  00
....................   
....................   
.................... void lcd_send_byte( BYTE address, BYTE n ) {  
....................   
....................       lcd.rs = 0;  
*
00A4:  BCF    F83.1
....................       while ( bit_test(lcd_read_byte(),7) ) ;  
00A6:  BRA    005C
00A8:  MOVFF  01,3F
00AC:  BTFSC  01.7
00AE:  BRA    00A6
....................       lcd.rs = address;  
00B0:  BTFSS  3D.0
00B2:  BCF    F83.1
00B4:  BTFSC  3D.0
00B6:  BSF    F83.1
....................       delay_cycles(1);  
00B8:  NOP   
....................       lcd.rw = 0;  
00BA:  BCF    F83.2
....................       delay_cycles(1);  
00BC:  NOP   
....................       lcd.enable = 0;  
00BE:  BCF    F83.0
....................       lcd_send_nibble(n >> 4);  
00C0:  SWAPF  3E,W
00C2:  MOVWF  3F
00C4:  MOVLW  0F
00C6:  ANDWF  3F,F
00C8:  MOVFF  3F,40
00CC:  RCALL  003E
....................       lcd_send_nibble(n & 0xf);  
00CE:  MOVF   3E,W
00D0:  ANDLW  0F
00D2:  MOVWF  3F
00D4:  MOVFF  3F,40
00D8:  RCALL  003E
.................... }  
00DA:  RETLW  00
....................   
....................   
.................... void lcd_init() {  
....................     BYTE i;  
....................     set_tris_lcd(LCD_WRITE);  
00DC:  MOVLW  00
00DE:  MOVWF  F95
....................     delay_ms(45);                                      // modified  
00E0:  MOVLW  2D
00E2:  MOVWF  39
00E4:  RCALL  0018
....................     lcd.rs = 0;  
00E6:  BCF    F83.1
....................     lcd.rw = 0;  
00E8:  BCF    F83.2
....................     lcd.enable = 0;  
00EA:  BCF    F83.0
....................     //delay_ms(15);                                    // modified  
....................     //for(i=1;i<=3;++i) {                              // modified  
....................     //   lcd_send_nibble(3);                           // modified  
....................     //   delay_ms(5);                                  // modified  
....................     //}                                                // modified  
....................     lcd_send_nibble(2);  
00EC:  MOVLW  02
00EE:  MOVWF  40
00F0:  RCALL  003E
....................     for(i=0;i<=3;++i)  
00F2:  CLRF   38
00F4:  MOVF   38,W
00F6:  SUBLW  03
00F8:  BNC   0114
....................        {                                                // modified  
....................           lcd_send_byte(0,LCD_INIT_STRING[i]);  
00FA:  CLRF   03
00FC:  MOVF   38,W
00FE:  RCALL  0004
0100:  MOVWF  39
0102:  CLRF   3D
0104:  MOVFF  39,3E
0108:  RCALL  00A4
....................           delay_ms(5);                                  // modified  
010A:  MOVLW  05
010C:  MOVWF  39
010E:  RCALL  0018
....................        }                                                // modified  
0110:  INCF   38,F
0112:  BRA    00F4
.................... }  
0114:  GOTO   0344 (RETURN)
....................   
....................   
.................... void lcd_gotoxy( BYTE x, BYTE y) {  
....................    BYTE address;  
....................   
....................    if(y!=1)  
*
0202:  DECFSZ 3A,W
0204:  BRA    0208
0206:  BRA    020E
....................      address=lcd_line_two;  
0208:  MOVLW  40
020A:  MOVWF  3B
....................    else  
020C:  BRA    0210
....................      address=0;  
020E:  CLRF   3B
....................    address+=x-1;  
0210:  MOVLW  01
0212:  SUBWF  39,W
0214:  ADDWF  3B,F
....................    lcd_send_byte(0,0x80|address);  
0216:  MOVF   3B,W
0218:  IORLW  80
021A:  MOVWF  3C
021C:  CLRF   3D
021E:  MOVFF  3C,3E
0222:  RCALL  00A4
.................... }  
0224:  GOTO   0268 (RETURN)
....................   
.................... void lcd_putc( char c) {  
....................    switch (c) {  
0228:  MOVF   38,W
022A:  XORLW  0C
022C:  BZ    0238
022E:  XORLW  06
0230:  BZ    0248
0232:  XORLW  02
0234:  BZ    0252
0236:  BRA    025C
....................      case '\f'   : lcd_send_byte(0,1);  
0238:  CLRF   3D
023A:  MOVLW  01
023C:  MOVWF  3E
023E:  RCALL  00A4
....................                    delay_ms(2);  
0240:  MOVLW  02
0242:  MOVWF  39
0244:  RCALL  0018
....................                                            break;  
0246:  BRA    0268
....................      case '\n'   : lcd_gotoxy(1,2);        break;  
0248:  MOVLW  01
024A:  MOVWF  39
024C:  MOVLW  02
024E:  MOVWF  3A
0250:  BRA    0202
....................      case '\b'   : lcd_send_byte(0,0x10);  break;  
0252:  CLRF   3D
0254:  MOVLW  10
0256:  MOVWF  3E
0258:  RCALL  00A4
025A:  BRA    0268
....................      default     : lcd_send_byte(1,c);     break;  
025C:  MOVLW  01
025E:  MOVWF  3D
0260:  MOVFF  38,3E
0264:  RCALL  00A4
0266:  BRA    0268
....................    }  
.................... }  
0268:  RETLW  00
....................   
.................... char lcd_getc( BYTE x, BYTE y) {  
....................    char value;  
....................   
....................     lcd_gotoxy(x,y);  
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low  
....................     lcd.rs=1;  
....................     value = lcd_read_byte();  
....................     lcd.rs=0;  
....................     return(value);  
.................... }  
....................  
....................   
....................   
....................   
....................  
....................   
....................   
.................... /*  
.................... float Vres = 5.0 / 1023.0;  
.................... float Voltage;  
....................   
.................... #INT_AD  
.................... void int_ad_isr(){  
....................    Voltage = (*ADRESL * Vres) - 3;  
.................... }  
.................... */  
....................   
.................... main(){  
....................   
026A:  CLRF   FF8
026C:  BCF    FD0.7
026E:  CLRF   FEA
0270:  CLRF   FE9
0272:  BSF    FC1.0
0274:  BSF    FC1.1
0276:  BSF    FC1.2
0278:  BSF    FC1.3
027A:  MOVLW  92
027C:  MOVWF  05
027E:  MOVLW  0F
0280:  MOVWF  06
0282:  MOVLW  93
0284:  MOVWF  07
0286:  MOVLW  0F
0288:  MOVWF  08
028A:  MOVLW  94
028C:  MOVWF  09
028E:  MOVLW  0F
0290:  MOVWF  0A
0292:  MOVLW  95
0294:  MOVWF  0B
0296:  MOVLW  0F
0298:  MOVWF  0C
029A:  MOVLW  96
029C:  MOVWF  0D
029E:  MOVLW  0F
02A0:  MOVWF  0E
02A2:  MOVLW  80
02A4:  MOVWF  0F
02A6:  MOVLW  0F
02A8:  MOVWF  10
02AA:  MOVLW  81
02AC:  MOVWF  11
02AE:  MOVLW  0F
02B0:  MOVWF  12
02B2:  MOVLW  82
02B4:  MOVWF  13
02B6:  MOVLW  0F
02B8:  MOVWF  14
02BA:  MOVLW  83
02BC:  MOVWF  15
02BE:  MOVLW  0F
02C0:  MOVWF  16
02C2:  MOVLW  84
02C4:  MOVWF  17
02C6:  MOVLW  0F
02C8:  MOVWF  18
02CA:  MOVLW  89
02CC:  MOVWF  19
02CE:  MOVLW  0F
02D0:  MOVWF  1A
02D2:  MOVLW  8A
02D4:  MOVWF  1B
02D6:  MOVLW  0F
02D8:  MOVWF  1C
02DA:  MOVLW  8B
02DC:  MOVWF  1D
02DE:  MOVLW  0F
02E0:  MOVWF  1E
02E2:  MOVLW  8C
02E4:  MOVWF  1F
02E6:  MOVLW  0F
02E8:  MOVWF  20
02EA:  MOVLW  8D
02EC:  MOVWF  21
02EE:  MOVLW  0F
02F0:  MOVWF  22
02F2:  MOVLW  C4
02F4:  MOVWF  23
02F6:  MOVLW  0F
02F8:  MOVWF  24
02FA:  MOVLW  C3
02FC:  MOVWF  25
02FE:  MOVLW  0F
0300:  MOVWF  26
0302:  MOVLW  C2
0304:  MOVWF  27
0306:  MOVLW  0F
0308:  MOVWF  28
030A:  MOVLW  C1
030C:  MOVWF  29
030E:  MOVLW  0F
0310:  MOVWF  2A
0312:  MOVLW  C0
0314:  MOVWF  2B
0316:  MOVLW  0F
0318:  MOVWF  2C
031A:  MOVLW  F2
031C:  MOVWF  2D
031E:  MOVLW  0F
0320:  MOVWF  2E
0322:  MOVLW  F1
0324:  MOVWF  2F
0326:  MOVLW  0F
0328:  MOVWF  30
032A:  MOVLW  F0
032C:  MOVWF  31
032E:  MOVLW  0F
0330:  MOVWF  32
0332:  MOVLW  9D
0334:  MOVWF  33
0336:  MOVLW  0F
0338:  MOVWF  34
033A:  MOVLW  81
033C:  MOVWF  35
033E:  MOVLW  0F
0340:  MOVWF  36
....................    /*  
....................    lcd_init();  
....................    //printf(lcd_putc, "\fHello \n:)");  
....................   
....................    ADCON0->ADON = 1;  
....................    ADCON0->CHSx = 0;  
....................    ADCON1->PCFGX = 8;  
....................   
....................    *TRISA = 0x01;  // set A0 as input  
....................   
....................    ADCON2->ADFM = 1; // right justify  
....................   
....................    // enable references  
....................    ADCON1->VCFG0 = 1;  
....................    ADCON1->VCFG1 = 1;  
....................   
....................   
....................    // interrupt setup  
....................    PIE1->ADIE = 1;  
....................    INTCON->GIE = 1;  
....................    INTCON->PEIE = 1;  
....................   
....................    while(1){  
....................   
....................       printf(lcd_putc, "\f %fV", Voltage);  
....................       //printf(lcd_putc, "\n %f", *Q );  
....................       ADCON0->GODONE = 1;  
....................       delay_ms(300);  
....................   
....................    };  
....................    */  
....................   
....................    char press;  
....................    lcd_init();  
0342:  BRA    00DC
....................    *TRISB = 0xF0;  
0344:  MOVF   07,W
0346:  MOVWF  FE9
0348:  MOVFF  08,FEA
034C:  MOVLW  F0
034E:  MOVWF  FEF
....................    *TRISC = 0x00;  
0350:  MOVF   09,W
0352:  MOVWF  FE9
0354:  MOVFF  0A,FEA
0358:  CLRF   FEF
....................    ADCON1->PCFGx = 0x0F;  
035A:  MOVF   29,W
035C:  MOVWF  FE9
035E:  MOVF   2A,W
0360:  MOVWF  FEA
0362:  MOVLW  F0
0364:  ANDWF  FEF,W
0366:  IORLW  0F
0368:  MOVWF  FEF
....................    INTCON2->RBPU = 0;  
036A:  MOVF   2F,W
036C:  MOVWF  FE9
036E:  MOVF   30,W
0370:  MOVWF  FEA
0372:  BCF    FEF.7
....................   
....................    while(1){  
....................       press = keyPress();  
0374:  BRA    0118
0376:  MOVFF  01,37
....................       if( press != '@'){  
037A:  MOVF   37,W
037C:  SUBLW  40
037E:  BZ    0392
....................          printf(lcd_putc, "\f %c", press);  
0380:  MOVLW  0C
0382:  MOVWF  38
0384:  RCALL  0228
0386:  MOVLW  20
0388:  MOVWF  38
038A:  RCALL  0228
038C:  MOVFF  37,38
0390:  RCALL  0228
....................       }  
....................       // *PORTC ^= 0xFF;  
....................       delay_ms(10);  
0392:  MOVLW  0A
0394:  MOVWF  39
0396:  RCALL  0018
....................    }  
0398:  BRA    0374
.................... }  
....................  
039A:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0F   BROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
