CCS PCH C Compiler, Version 3.214, 26547               24-Sep-15 14:24

               Filename: H:\Electrical Engineering Technology\Classes\Microcontrollers\Code\LCD\lcd_0.LST

               ROM used: 1838 bytes (6%)
                         Largest free fragment is 30930
               RAM used: 44 (3%) at main() level
                         72 (5%) worst case
               Stack:    5 locations

*
0000:  GOTO   0592
....................  /* Initial lcd test  
....................    2015-.09.24  
....................    ../../designs/LCDpanel_1.design  
.................... */  
....................   
.................... #include <18f4520.h> 
....................  //////// Standard Header file for the PIC18F4520 device ////////////////  
.................... #device PIC18F4520  
.................... #list  
....................  
.................... #use delay (clock = 200000000)  
*
0030:  CLRF   FEA
0032:  MOVLW  3F
0034:  MOVWF  FE9
0036:  MOVF   FEF,W
0038:  BZ    0054
003A:  MOVLW  40
003C:  MOVWF  01
003E:  CLRF   00
0040:  DECFSZ 00,F
0042:  BRA    0040
0044:  DECFSZ 01,F
0046:  BRA    003E
0048:  MOVLW  D9
004A:  MOVWF  00
004C:  DECFSZ 00,F
004E:  BRA    004C
0050:  DECFSZ FEF,F
0052:  BRA    003A
0054:  RETLW  00
.................... #fuses HS, NOWDT, NOLvP  
.................... #include "../Library/18f4520ptr.h" 
....................  #include "../library/GPIO.h" 
....................  // GPIO  
.................... int *TRISA = 0xF92;  
.................... int *TRISB = 0xF93;  
.................... int *TRISC = 0xF94;  
....................   
.................... int *PORTA = 0xF80;  
.................... int *PORTB = 0xF81;  
.................... int *PORTC = 0xF82;  
....................  
.................... #include "../library/Analog.h" 
....................  // Analog to digital circuit  
.................... // INT *ADCON1 = 0xFC1;  
....................   
.................... #define L *ADRESH  
.................... #define Q *ADRESL  
....................   
.................... int16 *ADRESH = 0xFC4;  
.................... int16 *ADRESL = 0xFC3;  
....................   
.................... struct ADCON_0{  
....................    int ADON:1;  
....................    int GODONE:1;  
....................    int CHSx:4;  
....................    int unused:2;  
.................... };  
.................... struct ADCON_0 *ADCON0 = 0xFC2;  
....................   
.................... struct ADCON_1{  
....................    int PCFGx:4;  
....................    int VCFG0:1;  
....................    int VCFG1:1;  
....................    int unused:2;  
.................... };  
.................... struct ADCON_1 *ADCON1 = 0xFC1;  
....................   
.................... struct ADCON_2{  
....................    int ADCSx:3;  
....................    int ACQTx:3;  
....................    int unused:1;  
....................    int ADFM:1;  
.................... };  
.................... struct ADCON_2 *ADCON2 = 0xFC0;  
....................  
.................... #include "../library/Interrupts.h" 
....................  // External interrupt control  
....................   
.................... // int *INTCON0=0xFF2;  
.................... // int *INTCON1=0xFF1;  
.................... // int *INTCON2=0xFF0;  
....................   
.................... struct INTCON_0{  
.................... 	int RBIF:1;  
.................... 	int INT0IF:1;  
.................... 	int TMR0IF:1;  
.................... 	int RBIE:1;  
.................... 	int INT0IE:1;  
.................... 	int TMR0IE:1;  
.................... 	int PEIE:1;  
.................... 	int GIE:1;  
.................... 	};  
.................... struct INTCON_0 *INTCON0 = 0xFF2;  
....................   
.................... struct INTCON_1{  
.................... 	int RBIP:1;  
.................... 	int UNIMPLEMENTED_0:1;  
.................... 	int TMROIP:1;  
.................... 	int UNIMPLEMENTED_1:1;  
.................... 	int INTEDG2:1;  
.................... 	int INTEDG1:1;  
.................... 	int INTEDG0:1;  
.................... 	int RBPU:1;  
.................... 	};  
.................... struct INTCON_1 *INTCON1 = 0xFF1;  
....................   
.................... struct INTCON_2{  
.................... 	int INT1F:1;  
.................... 	int INT2F:1;  
.................... 	int UNIMPLEMENTED_0:1;  
.................... 	int INT1E:1;  
.................... 	int INT2E:1;  
.................... 	int UNIMPLEMENTED_1:1;  
.................... 	int INT1P:1;  
.................... 	int INT2P:1;  
.................... 	};  
.................... struct INTCON_2 *INTCON2 = 0xFF0;  
....................  
.................... #include "../library/PeripheralInterrupts.h" 
....................  // Peripheral Interrupts Control Registers  
....................   
.................... struct PIE_1{  
.................... 	int TMR1IE:1;  
.................... 	int TMR2IE:1;  
.................... 	int CCP1IE:1;  
.................... 	int SSPIE:1;  
.................... 	int TXIE:1;  
.................... 	int RCIE:1;  
.................... 	int ADIE:1;  
.................... 	int PSPIE:1;  
.................... 	};  
.................... struct PIE_1 *PIE1 = 0xFF2;  
....................  
....................   
....................   
....................   
....................  
.................... #include "../library/modifiedlcd.h" 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////                             Modified LCD.C                        ////  
.................... ////                 Driver for common LCD modules                     ////  
.................... ////                                                                   ////  
.................... ////  lcd_init()   Must be called before any other function.           ////  
.................... ////         ***This function was modified to fit the Samsumgs6A0069   ////  
.................... ////                                                                   ////  
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     ////  
.................... ////                     The following have special meaning:           ////  
.................... ////                      \f  Clear display                            ////  
.................... ////                      \n  Go to start of second line               ////  
.................... ////                      \b  Move back one position                   ////  
.................... ////                                                                   ////  
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    ////  
.................... ////                                                                   ////  
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         ////  
.................... ////                                                                   ////  
.................... ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... // As defined in the following structure the pin connection is as follows:  
.................... //     D0  enable  
.................... //     D1  rs  
.................... //     D2  rw  
.................... //     D4  D4  
.................... //     D5  D5  
.................... //     D6  D6  
.................... //     D7  D7  
.................... //  
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used.  
....................   
.................... // Un-comment the following define to use port B  
.................... #define use_portb_lcd FALSE  
....................   
....................   
.................... struct lcd_pin_map {                 // This structure is overlayed  
....................            BOOLEAN enable;           // on to an I/O port to gain  
....................            BOOLEAN rs;               // access to the LCD pins.  
....................            BOOLEAN rw;               // The bits are allocated from  
....................            BOOLEAN unused;           // low order up.  ENABLE will  
....................            int     data : 4;         // be pin B0.  
....................         }lcd;  
.................... //struct lcd_pin_map *lcd = 0xF83;  
....................   
.................... //#if defined(__PCH__)  
.................... //#if defined use_portb_lcd  
.................... //   #byte lcd = 0xF81                   // This puts the entire structure  
.................... //#else  
....................    #byte lcd = 0xF83                   // This puts the entire structure  
.................... //#endif  
.................... //#else  
.................... //#if defined use_portb_lcd  
.................... //   #byte lcd = 6                  // on to port B (at address 6)                ????????? 
.................... //#else  
.................... //   #byte lcd = 8                 // on to port D (at address 8)  
.................... //#endif  
.................... //#endif  
....................   
.................... //#if defined use_portb_lcd  
.................... //   #define set_tris_lcd(x) set_tris_b(x)  
.................... //#else  
....................    #define set_tris_lcd(x) set_tris_d(x)  
.................... //#endif  
....................   
....................   
.................... #define lcd_type 3           // 0=5x7, 1=5x10, 2=2 lines, 3=2 lines Disp ON  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line             ?????????? 
....................   
....................   
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0x0f, 0x01, 0x06};  
....................                              // These bytes need to be sent to the LCD  
....................                              // to start it up.  
....................   
....................   
....................                              // The following are used for setting  
....................                              // the I/O port direction register.  
....................   
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out  
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in  
....................   
....................   
....................   
.................... BYTE lcd_read_byte() {  
....................       BYTE low,high;  
....................       set_tris_lcd(LCD_READ);  
*
0074:  MOVLW  F0
0076:  MOVWF  F95
....................       lcd.rw = 1;  
0078:  BSF    F83.2
....................       delay_cycles(1);  
007A:  NOP   
....................       lcd.enable = 1;  
007C:  BSF    F83.0
....................       delay_cycles(1);  
007E:  NOP   
....................       high = lcd.data;  
0080:  SWAPF  F83,W
0082:  ANDLW  0F
0084:  MOVWF  46
....................       lcd.enable = 0;  
0086:  BCF    F83.0
....................       delay_cycles(1);  
0088:  NOP   
....................       lcd.enable = 1;  
008A:  BSF    F83.0
....................       delay_us(1);  
008C:  MOVLW  10
008E:  MOVWF  00
0090:  DECFSZ 00,F
0092:  BRA    0090
0094:  NOP   
....................       low = lcd.data;  
0096:  SWAPF  F83,W
0098:  ANDLW  0F
009A:  MOVWF  45
....................       lcd.enable = 0;  
009C:  BCF    F83.0
....................       set_tris_lcd(LCD_WRITE);  
009E:  MOVLW  00
00A0:  MOVWF  F95
....................       return( (high<<4) | low);  
00A2:  SWAPF  46,W
00A4:  MOVWF  00
00A6:  MOVLW  F0
00A8:  ANDWF  00,F
00AA:  MOVF   00,W
00AC:  IORWF  45,W
00AE:  MOVWF  01
.................... }  
00B0:  GOTO   00B8 (RETURN)
....................   
....................   
.................... void lcd_send_nibble( BYTE n ) {  
....................       lcd.data = n;  
*
0056:  SWAPF  46,W
0058:  ANDLW  F0
005A:  MOVWF  00
005C:  MOVLW  0F
005E:  ANDWF  F83,W
0060:  IORWF  00,W
0062:  MOVWF  F83
....................       delay_cycles(1);  
0064:  NOP   
....................       lcd.enable = 1;  
0066:  BSF    F83.0
....................       delay_us(2);  
0068:  MOVLW  21
006A:  MOVWF  00
006C:  DECFSZ 00,F
006E:  BRA    006C
....................       lcd.enable = 0;  
0070:  BCF    F83.0
.................... }  
0072:  RETLW  00
....................   
....................   
.................... void lcd_send_byte( BYTE address, BYTE n ) {  
....................   
....................       lcd.rs = 0;  
*
00B4:  BCF    F83.1
....................       while ( bit_test(lcd_read_byte(),7) ) ;  
00B6:  BRA    0074
00B8:  MOVFF  01,45
00BC:  BTFSC  01.7
00BE:  BRA    00B6
....................       lcd.rs = address;  
00C0:  BTFSS  43.0
00C2:  BCF    F83.1
00C4:  BTFSC  43.0
00C6:  BSF    F83.1
....................       delay_cycles(1);  
00C8:  NOP   
....................       lcd.rw = 0;  
00CA:  BCF    F83.2
....................       delay_cycles(1);  
00CC:  NOP   
....................       lcd.enable = 0;  
00CE:  BCF    F83.0
....................       lcd_send_nibble(n >> 4);  
00D0:  SWAPF  44,W
00D2:  MOVWF  45
00D4:  MOVLW  0F
00D6:  ANDWF  45,F
00D8:  MOVFF  45,46
00DC:  RCALL  0056
....................       lcd_send_nibble(n & 0xf);  
00DE:  MOVF   44,W
00E0:  ANDLW  0F
00E2:  MOVWF  45
00E4:  MOVFF  45,46
00E8:  RCALL  0056
.................... }  
00EA:  RETLW  00
....................   
....................   
.................... void lcd_init() {  
....................     BYTE i;  
....................     set_tris_lcd(LCD_WRITE);  
00EC:  MOVLW  00
00EE:  MOVWF  F95
....................     delay_ms(45);                                      // modified  
00F0:  MOVLW  2D
00F2:  MOVWF  3F
00F4:  RCALL  0030
....................     lcd.rs = 0;  
00F6:  BCF    F83.1
....................     lcd.rw = 0;  
00F8:  BCF    F83.2
....................     lcd.enable = 0;  
00FA:  BCF    F83.0
....................     //delay_ms(15);                                    // modified  
....................     //for(i=1;i<=3;++i) {                              // modified  
....................     //   lcd_send_nibble(3);                           // modified  
....................     //   delay_ms(5);                                  // modified  
....................     //}                                                // modified  
....................     lcd_send_nibble(2);  
00FC:  MOVLW  02
00FE:  MOVWF  46
0100:  RCALL  0056
....................     for(i=0;i<=3;++i)  
0102:  CLRF   27
0104:  MOVF   27,W
0106:  SUBLW  03
0108:  BNC   0124
....................        {                                                // modified  
....................           lcd_send_byte(0,LCD_INIT_STRING[i]);  
010A:  CLRF   03
010C:  MOVF   27,W
010E:  RCALL  0004
0110:  MOVWF  28
0112:  CLRF   43
0114:  MOVFF  28,44
0118:  RCALL  00B4
....................           delay_ms(5);                                  // modified  
011A:  MOVLW  05
011C:  MOVWF  3F
011E:  RCALL  0030
....................        }                                                // modified  
0120:  INCF   27,F
0122:  BRA    0104
.................... }  
0124:  GOTO   0634 (RETURN)
....................   
....................   
.................... void lcd_gotoxy( BYTE x, BYTE y) {  
....................    BYTE address;  
....................   
....................    if(y!=1)  
0128:  DECFSZ 40,W
012A:  BRA    012E
012C:  BRA    0134
....................      address=lcd_line_two;  
012E:  MOVLW  40
0130:  MOVWF  41
....................    else  
0132:  BRA    0136
....................      address=0;  
0134:  CLRF   41
....................    address+=x-1;  
0136:  MOVLW  01
0138:  SUBWF  3F,W
013A:  ADDWF  41,F
....................    lcd_send_byte(0,0x80|address);  
013C:  MOVF   41,W
013E:  IORLW  80
0140:  MOVWF  42
0142:  CLRF   43
0144:  MOVFF  42,44
0148:  RCALL  00B4
.................... }  
014A:  GOTO   018E (RETURN)
....................   
.................... void lcd_putc( char c) {  
....................    switch (c) {  
014E:  MOVF   3E,W
0150:  XORLW  0C
0152:  BZ    015E
0154:  XORLW  06
0156:  BZ    016E
0158:  XORLW  02
015A:  BZ    0178
015C:  BRA    0182
....................      case '\f'   : lcd_send_byte(0,1);  
015E:  CLRF   43
0160:  MOVLW  01
0162:  MOVWF  44
0164:  RCALL  00B4
....................                    delay_ms(2);  
0166:  MOVLW  02
0168:  MOVWF  3F
016A:  RCALL  0030
....................                                            break;  
016C:  BRA    018E
....................      case '\n'   : lcd_gotoxy(1,2);        break;  
016E:  MOVLW  01
0170:  MOVWF  3F
0172:  MOVLW  02
0174:  MOVWF  40
0176:  BRA    0128
....................      case '\b'   : lcd_send_byte(0,0x10);  break;  
0178:  CLRF   43
017A:  MOVLW  10
017C:  MOVWF  44
017E:  RCALL  00B4
0180:  BRA    018E
....................      default     : lcd_send_byte(1,c);     break;  
0182:  MOVLW  01
0184:  MOVWF  43
0186:  MOVFF  3E,44
018A:  RCALL  00B4
018C:  BRA    018E
....................    }  
.................... }  
018E:  RETLW  00
....................   
.................... char lcd_getc( BYTE x, BYTE y) {  
....................    char value;  
....................   
....................     lcd_gotoxy(x,y);  
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low  
....................     lcd.rs=1;  
....................     value = lcd_read_byte();  
....................     lcd.rs=0;  
....................     return(value);  
.................... }  
....................  
....................   
.................... float Vres = 5.0 / 1023.0;  
....................   
.................... main(){  
....................   
*
0592:  CLRF   FF8
0594:  BCF    FD0.7
0596:  CLRF   FEA
0598:  CLRF   FE9
059A:  MOVF   FC1,W
059C:  ANDLW  C0
059E:  IORLW  03
05A0:  MOVWF  FC1
05A2:  MOVLW  07
05A4:  MOVWF  FB4
05A6:  MOVF   FB4,W
05A8:  BCF    FA1.6
05AA:  MOVLW  92
05AC:  MOVWF  05
05AE:  MOVLW  0F
05B0:  MOVWF  06
05B2:  MOVLW  93
05B4:  MOVWF  07
05B6:  MOVLW  0F
05B8:  MOVWF  08
05BA:  MOVLW  94
05BC:  MOVWF  09
05BE:  MOVLW  0F
05C0:  MOVWF  0A
05C2:  MOVLW  80
05C4:  MOVWF  0B
05C6:  MOVLW  0F
05C8:  MOVWF  0C
05CA:  MOVLW  81
05CC:  MOVWF  0D
05CE:  MOVLW  0F
05D0:  MOVWF  0E
05D2:  MOVLW  82
05D4:  MOVWF  0F
05D6:  MOVLW  0F
05D8:  MOVWF  10
05DA:  MOVLW  C4
05DC:  MOVWF  11
05DE:  MOVLW  0F
05E0:  MOVWF  12
05E2:  MOVLW  C3
05E4:  MOVWF  13
05E6:  MOVLW  0F
05E8:  MOVWF  14
05EA:  MOVLW  C2
05EC:  MOVWF  15
05EE:  MOVLW  0F
05F0:  MOVWF  16
05F2:  MOVLW  C1
05F4:  MOVWF  17
05F6:  MOVLW  0F
05F8:  MOVWF  18
05FA:  MOVLW  C0
05FC:  MOVWF  19
05FE:  MOVLW  0F
0600:  MOVWF  1A
0602:  MOVLW  F2
0604:  MOVWF  1B
0606:  MOVLW  0F
0608:  MOVWF  1C
060A:  MOVLW  F1
060C:  MOVWF  1D
060E:  MOVLW  0F
0610:  MOVWF  1E
0612:  MOVLW  F0
0614:  MOVWF  1F
0616:  MOVLW  0F
0618:  MOVWF  20
061A:  MOVLW  F2
061C:  MOVWF  21
061E:  MOVLW  0F
0620:  MOVWF  22
0622:  MOVLW  77
0624:  MOVWF  23
0626:  MOVLW  20
0628:  MOVWF  24
062A:  MOVLW  28
062C:  MOVWF  25
062E:  MOVLW  0A
0630:  MOVWF  26
....................    lcd_init();  
0632:  BRA    00EC
....................    //printf(lcd_putc, "\fHello \n:)");  
....................   
....................    ADCON0->ADON = 1;  
0634:  MOVFF  15,FE9
0638:  MOVFF  16,FEA
063C:  BSF    FEF.0
....................    ADCON0->CHSx = 1;  
063E:  MOVFF  15,FE9
0642:  MOVFF  16,FEA
0646:  MOVLW  C3
0648:  ANDWF  FEF,W
064A:  IORLW  04
064C:  MOVWF  FEF
....................    ADCON1->PCFGX = 8;  
064E:  MOVFF  17,FE9
0652:  MOVFF  18,FEA
0656:  MOVLW  F0
0658:  ANDWF  FEF,W
065A:  IORLW  08
065C:  MOVWF  FEF
....................   
....................    *TRISA = 0x01;  // set A0 as input  
065E:  MOVFF  05,FE9
0662:  MOVFF  06,FEA
0666:  MOVLW  01
0668:  MOVWF  FEF
....................   
....................    ADCON2->ADFM = 1; // right justify  
066A:  MOVFF  19,FE9
066E:  MOVFF  1A,FEA
0672:  BSF    FEF.7
....................   
....................    while(1){  
....................   
....................       ADCON0->GODONE = 1; // go  
0674:  MOVFF  15,FE9
0678:  MOVFF  16,FEA
067C:  BSF    FEF.1
....................         
....................       while(ADCON0->GODONE){}  
067E:  MOVFF  15,FE9
0682:  MOVFF  16,FEA
0686:  BTFSS  FEF.1
0688:  BRA    068C
068A:  BRA    067E
....................         
....................       printf(lcd_putc, "\f lcd_0");  
068C:  CLRF   27
068E:  MOVF   27,W
0690:  RCALL  0018
0692:  INCF   27,F
0694:  MOVWF  00
0696:  MOVFF  00,3E
069A:  RCALL  014E
069C:  MOVLW  07
069E:  SUBWF  27,W
06A0:  BNZ   068E
....................       printf(lcd_putc, "\n %f", *Q * Vres);  
06A2:  MOVFF  13,FE9
06A6:  MOVFF  14,FEA
06AA:  MOVFF  FEC,03
06AE:  MOVF   FED,F
06B0:  MOVFF  FEF,FE9
06B4:  MOVFF  03,FEA
06B8:  CLRF   29
06BA:  MOVFF  FEF,28
06BE:  BRA    0190
06C0:  MOVFF  03,2B
06C4:  MOVFF  02,2A
06C8:  MOVFF  01,29
06CC:  MOVFF  00,28
06D0:  MOVFF  26,2F
06D4:  MOVFF  25,2E
06D8:  MOVFF  24,2D
06DC:  MOVFF  23,2C
06E0:  BRA    01CA
06E2:  MOVFF  00,28
06E6:  MOVFF  01,29
06EA:  MOVFF  02,2A
06EE:  MOVFF  03,2B
06F2:  MOVLW  0A
06F4:  MOVWF  3E
06F6:  RCALL  014E
06F8:  MOVLW  20
06FA:  MOVWF  3E
06FC:  RCALL  014E
06FE:  MOVFF  2B,2F
0702:  MOVFF  2A,2E
0706:  MOVFF  29,2D
070A:  MOVFF  28,2C
070E:  CLRF   33
0710:  CLRF   32
0712:  MOVLW  01
0714:  MOVWF  31
0716:  MOVLW  06
0718:  MOVWF  30
071A:  BRA    02C0
....................       delay_ms(300);  
071C:  MOVLW  02
071E:  MOVWF  27
0720:  MOVLW  96
0722:  MOVWF  3F
0724:  RCALL  0030
0726:  DECFSZ 27,F
0728:  BRA    0720
....................   
....................    };  
072A:  BRA    0674
.................... }  
....................  
072C:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 1E0F   BROWNOUT NOWDT BORV25 NOPUT WDT32768
   Word  3: 8700   PBADEN CCP2C1 LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
